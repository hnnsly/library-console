// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: fines.sql

package postgres

import (
	"context"
	"time"

	"github.com/jackc/pgx/v5/pgtype"
)

const calculateOverdueFine = `-- name: CalculateOverdueFine :one
SELECT
    id as loan_history_id,
    GREATEST(0, EXTRACT(DAYS FROM (CURRENT_DATE - due_date))::int) as overdue_days,
    GREATEST(0, EXTRACT(DAYS FROM (CURRENT_DATE - due_date))::int) * $1 as calculated_fine
FROM loan_history
WHERE id = $2
`

type CalculateOverdueFineParams struct {
	DailyFineRate time.Time `json:"daily_fine_rate"`
	LoanHistoryID int32     `json:"loan_history_id"`
}

type CalculateOverdueFineRow struct {
	LoanHistoryID  int32       `json:"loan_history_id"`
	OverdueDays    interface{} `json:"overdue_days"`
	CalculatedFine int32       `json:"calculated_fine"`
}

func (q *Queries) CalculateOverdueFine(ctx context.Context, arg CalculateOverdueFineParams) (*CalculateOverdueFineRow, error) {
	row := q.db.QueryRow(ctx, calculateOverdueFine, arg.DailyFineRate, arg.LoanHistoryID)
	var i CalculateOverdueFineRow
	err := row.Scan(&i.LoanHistoryID, &i.OverdueDays, &i.CalculatedFine)
	return &i, err
}

const createFine = `-- name: CreateFine :one
INSERT INTO fines (
    loan_history_id, reader_id, fine_type, amount, fine_date, description, librarian_id
) VALUES (
    $1, $2, $3, $4, CURRENT_DATE, $5, $6
) RETURNING id, loan_history_id, reader_id, fine_type, amount, fine_date, payment_date, status, description, librarian_id, created_at, updated_at
`

type CreateFineParams struct {
	LoanHistoryID int32          `json:"loan_history_id"`
	ReaderID      int32          `json:"reader_id"`
	FineType      string         `json:"fine_type"`
	Amount        pgtype.Numeric `json:"amount"`
	Description   pgtype.Text    `json:"description"`
	LibrarianID   int32          `json:"librarian_id"`
}

func (q *Queries) CreateFine(ctx context.Context, arg CreateFineParams) (*Fine, error) {
	row := q.db.QueryRow(ctx, createFine,
		arg.LoanHistoryID,
		arg.ReaderID,
		arg.FineType,
		arg.Amount,
		arg.Description,
		arg.LibrarianID,
	)
	var i Fine
	err := row.Scan(
		&i.ID,
		&i.LoanHistoryID,
		&i.ReaderID,
		&i.FineType,
		&i.Amount,
		&i.FineDate,
		&i.PaymentDate,
		&i.Status,
		&i.Description,
		&i.LibrarianID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const getDebtorReaders = `-- name: GetDebtorReaders :many
SELECT
    r.full_name,
    r.ticket_number,
    r.phone,
    r.email,
    SUM(f.amount) as total_debt,
    COUNT(f.id) as fine_count
FROM readers r
JOIN fines f ON r.id = f.reader_id
WHERE f.status = 'unpaid'
GROUP BY r.id, r.full_name, r.ticket_number, r.phone, r.email
ORDER BY total_debt DESC
`

type GetDebtorReadersRow struct {
	FullName     string      `json:"full_name"`
	TicketNumber string      `json:"ticket_number"`
	Phone        pgtype.Text `json:"phone"`
	Email        pgtype.Text `json:"email"`
	TotalDebt    int64       `json:"total_debt"`
	FineCount    int64       `json:"fine_count"`
}

func (q *Queries) GetDebtorReaders(ctx context.Context) ([]*GetDebtorReadersRow, error) {
	rows, err := q.db.Query(ctx, getDebtorReaders)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetDebtorReadersRow
	for rows.Next() {
		var i GetDebtorReadersRow
		if err := rows.Scan(
			&i.FullName,
			&i.TicketNumber,
			&i.Phone,
			&i.Email,
			&i.TotalDebt,
			&i.FineCount,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getReaderFines = `-- name: GetReaderFines :many
SELECT f.id, f.loan_history_id, f.reader_id, f.fine_type, f.amount, f.fine_date, f.payment_date, f.status, f.description, f.librarian_id, f.created_at, f.updated_at, lh.loan_date, lh.due_date, b.title, b.author
FROM fines f
JOIN loan_history lh ON f.loan_history_id = lh.id
JOIN books b ON lh.book_id = b.id
WHERE f.reader_id = $1
ORDER BY f.fine_date DESC
`

type GetReaderFinesRow struct {
	ID            int32            `json:"id"`
	LoanHistoryID int32            `json:"loan_history_id"`
	ReaderID      int32            `json:"reader_id"`
	FineType      string           `json:"fine_type"`
	Amount        pgtype.Numeric   `json:"amount"`
	FineDate      time.Time        `json:"fine_date"`
	PaymentDate   pgtype.Date      `json:"payment_date"`
	Status        pgtype.Text      `json:"status"`
	Description   pgtype.Text      `json:"description"`
	LibrarianID   int32            `json:"librarian_id"`
	CreatedAt     pgtype.Timestamp `json:"created_at"`
	UpdatedAt     pgtype.Timestamp `json:"updated_at"`
	LoanDate      time.Time        `json:"loan_date"`
	DueDate       time.Time        `json:"due_date"`
	Title         string           `json:"title"`
	Author        string           `json:"author"`
}

func (q *Queries) GetReaderFines(ctx context.Context, readerID int32) ([]*GetReaderFinesRow, error) {
	rows, err := q.db.Query(ctx, getReaderFines, readerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetReaderFinesRow
	for rows.Next() {
		var i GetReaderFinesRow
		if err := rows.Scan(
			&i.ID,
			&i.LoanHistoryID,
			&i.ReaderID,
			&i.FineType,
			&i.Amount,
			&i.FineDate,
			&i.PaymentDate,
			&i.Status,
			&i.Description,
			&i.LibrarianID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.LoanDate,
			&i.DueDate,
			&i.Title,
			&i.Author,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUnpaidFines = `-- name: GetUnpaidFines :many
SELECT
    f.id, f.loan_history_id, f.reader_id, f.fine_type, f.amount, f.fine_date, f.payment_date, f.status, f.description, f.librarian_id, f.created_at, f.updated_at,
    r.full_name as reader_name,
    r.ticket_number,
    r.phone,
    b.title as book_title
FROM fines f
JOIN readers r ON f.reader_id = r.id
JOIN loan_history lh ON f.loan_history_id = lh.id
JOIN books b ON lh.book_id = b.id
WHERE f.status = 'unpaid'
ORDER BY f.fine_date DESC
`

type GetUnpaidFinesRow struct {
	ID            int32            `json:"id"`
	LoanHistoryID int32            `json:"loan_history_id"`
	ReaderID      int32            `json:"reader_id"`
	FineType      string           `json:"fine_type"`
	Amount        pgtype.Numeric   `json:"amount"`
	FineDate      time.Time        `json:"fine_date"`
	PaymentDate   pgtype.Date      `json:"payment_date"`
	Status        pgtype.Text      `json:"status"`
	Description   pgtype.Text      `json:"description"`
	LibrarianID   int32            `json:"librarian_id"`
	CreatedAt     pgtype.Timestamp `json:"created_at"`
	UpdatedAt     pgtype.Timestamp `json:"updated_at"`
	ReaderName    string           `json:"reader_name"`
	TicketNumber  string           `json:"ticket_number"`
	Phone         pgtype.Text      `json:"phone"`
	BookTitle     string           `json:"book_title"`
}

func (q *Queries) GetUnpaidFines(ctx context.Context) ([]*GetUnpaidFinesRow, error) {
	rows, err := q.db.Query(ctx, getUnpaidFines)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetUnpaidFinesRow
	for rows.Next() {
		var i GetUnpaidFinesRow
		if err := rows.Scan(
			&i.ID,
			&i.LoanHistoryID,
			&i.ReaderID,
			&i.FineType,
			&i.Amount,
			&i.FineDate,
			&i.PaymentDate,
			&i.Status,
			&i.Description,
			&i.LibrarianID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ReaderName,
			&i.TicketNumber,
			&i.Phone,
			&i.BookTitle,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const payFine = `-- name: PayFine :exec
UPDATE fines
SET status = 'paid', payment_date = CURRENT_DATE, updated_at = NOW()
WHERE id = $1
`

func (q *Queries) PayFine(ctx context.Context, fineID int32) error {
	_, err := q.db.Exec(ctx, payFine, fineID)
	return err
}

const waiveFine = `-- name: WaiveFine :exec
UPDATE fines
SET status = 'waived', updated_at = NOW()
WHERE id = $1
`

func (q *Queries) WaiveFine(ctx context.Context, fineID int32) error {
	_, err := q.db.Exec(ctx, waiveFine, fineID)
	return err
}
