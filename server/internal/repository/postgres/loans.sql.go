// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: loans.sql

package postgres

import (
	"context"
	"time"

	"github.com/govalues/decimal"
)

const checkLoanEligibility = `-- name: CheckLoanEligibility :one
SELECT
    b.available_copies > 0 as book_available,
    (SELECT COUNT(*) FROM loan_history lh WHERE lh.reader_id = $1 AND lh.status = 'active') as current_loans,
    r.max_books_allowed,
    r.status as reader_status,
    r.total_debt,
    (SELECT COUNT(*) FROM reservations res WHERE res.book_id = $2 AND res.status = 'active' AND res.reader_id != $1) as queue_length
FROM books b, readers r
WHERE b.id = $2 AND r.id = $1
`

type CheckLoanEligibilityParams struct {
	ReaderID int `json:"reader_id"`
	BookID   int `json:"book_id"`
}

type CheckLoanEligibilityRow struct {
	BookAvailable   bool            `json:"book_available"`
	CurrentLoans    int64           `json:"current_loans"`
	MaxBooksAllowed int             `json:"max_books_allowed"`
	ReaderStatus    string          `json:"reader_status"`
	TotalDebt       decimal.Decimal `json:"total_debt"`
	QueueLength     int64           `json:"queue_length"`
}

func (q *Queries) CheckLoanEligibility(ctx context.Context, arg CheckLoanEligibilityParams) (*CheckLoanEligibilityRow, error) {
	row := q.db.QueryRow(ctx, checkLoanEligibility, arg.ReaderID, arg.BookID)
	var i CheckLoanEligibilityRow
	err := row.Scan(
		&i.BookAvailable,
		&i.CurrentLoans,
		&i.MaxBooksAllowed,
		&i.ReaderStatus,
		&i.TotalDebt,
		&i.QueueLength,
	)
	return &i, err
}

const createLoan = `-- name: CreateLoan :one
INSERT INTO loan_history (
    book_id, reader_id, librarian_id, loan_date, due_date, status
) VALUES (
    $1, $2, $3, CURRENT_DATE,
    CURRENT_DATE + INTERVAL '@loan_days days', 'active'
) RETURNING id, book_id, reader_id, librarian_id, loan_date, due_date, return_date, renewals_count, status, fine_amount, fine_paid, comments, return_librarian_id, created_at, updated_at
`

type CreateLoanParams struct {
	BookID      int `json:"book_id"`
	ReaderID    int `json:"reader_id"`
	LibrarianID int `json:"librarian_id"`
}

func (q *Queries) CreateLoan(ctx context.Context, arg CreateLoanParams) (*LoanHistory, error) {
	row := q.db.QueryRow(ctx, createLoan, arg.BookID, arg.ReaderID, arg.LibrarianID)
	var i LoanHistory
	err := row.Scan(
		&i.ID,
		&i.BookID,
		&i.ReaderID,
		&i.LibrarianID,
		&i.LoanDate,
		&i.DueDate,
		&i.ReturnDate,
		&i.RenewalsCount,
		&i.Status,
		&i.FineAmount,
		&i.FinePaid,
		&i.Comments,
		&i.ReturnLibrarianID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const createRenewal = `-- name: CreateRenewal :exec
INSERT INTO renewals (
    loan_history_id, renewal_date, old_due_date, new_due_date, librarian_id, reason
) VALUES (
    $1, CURRENT_DATE, $2, $3, $4, $5
)
`

type CreateRenewalParams struct {
	LoanHistoryID int       `json:"loan_history_id"`
	OldDueDate    time.Time `json:"old_due_date"`
	NewDueDate    time.Time `json:"new_due_date"`
	LibrarianID   int       `json:"librarian_id"`
	Reason        *string   `json:"reason"`
}

func (q *Queries) CreateRenewal(ctx context.Context, arg CreateRenewalParams) error {
	_, err := q.db.Exec(ctx, createRenewal,
		arg.LoanHistoryID,
		arg.OldDueDate,
		arg.NewDueDate,
		arg.LibrarianID,
		arg.Reason,
	)
	return err
}

const getActiveLoansByBook = `-- name: GetActiveLoansByBook :many
SELECT
    lh.id,
    r.full_name as reader_name,
    r.ticket_number,
    lh.loan_date,
    lh.due_date,
    lh.renewals_count
FROM loan_history lh
JOIN readers r ON lh.reader_id = r.id
WHERE lh.book_id = $1 AND lh.status = 'active'
ORDER BY lh.loan_date DESC
`

type GetActiveLoansByBookRow struct {
	ID            int64     `json:"id"`
	ReaderName    string    `json:"reader_name"`
	TicketNumber  string    `json:"ticket_number"`
	LoanDate      time.Time `json:"loan_date"`
	DueDate       time.Time `json:"due_date"`
	RenewalsCount int       `json:"renewals_count"`
}

func (q *Queries) GetActiveLoansByBook(ctx context.Context, bookID int) ([]*GetActiveLoansByBookRow, error) {
	rows, err := q.db.Query(ctx, getActiveLoansByBook, bookID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetActiveLoansByBookRow{}
	for rows.Next() {
		var i GetActiveLoansByBookRow
		if err := rows.Scan(
			&i.ID,
			&i.ReaderName,
			&i.TicketNumber,
			&i.LoanDate,
			&i.DueDate,
			&i.RenewalsCount,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getBooksDueToday = `-- name: GetBooksDueToday :many
SELECT
    b.title,
    b.author,
    r.full_name as reader_name,
    r.phone,
    lh.loan_date,
    lh.renewals_count
FROM loan_history lh
JOIN books b ON lh.book_id = b.id
JOIN readers r ON lh.reader_id = r.id
WHERE lh.status = 'active' AND lh.due_date = CURRENT_DATE
ORDER BY r.full_name
`

type GetBooksDueTodayRow struct {
	Title         string    `json:"title"`
	Author        string    `json:"author"`
	ReaderName    string    `json:"reader_name"`
	Phone         *string   `json:"phone"`
	LoanDate      time.Time `json:"loan_date"`
	RenewalsCount int       `json:"renewals_count"`
}

func (q *Queries) GetBooksDueToday(ctx context.Context) ([]*GetBooksDueTodayRow, error) {
	rows, err := q.db.Query(ctx, getBooksDueToday)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetBooksDueTodayRow{}
	for rows.Next() {
		var i GetBooksDueTodayRow
		if err := rows.Scan(
			&i.Title,
			&i.Author,
			&i.ReaderName,
			&i.Phone,
			&i.LoanDate,
			&i.RenewalsCount,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLoanByID = `-- name: GetLoanByID :one
SELECT lh.id, lh.book_id, lh.reader_id, lh.librarian_id, lh.loan_date, lh.due_date, lh.return_date, lh.renewals_count, lh.status, lh.fine_amount, lh.fine_paid, lh.comments, lh.return_librarian_id, lh.created_at, lh.updated_at, b.title, b.author, r.full_name as reader_name
FROM loan_history lh
JOIN books b ON lh.book_id = b.id
JOIN readers r ON lh.reader_id = r.id
WHERE lh.id = $1
`

type GetLoanByIDRow struct {
	ID                int64           `json:"id"`
	BookID            int             `json:"book_id"`
	ReaderID          int             `json:"reader_id"`
	LibrarianID       int             `json:"librarian_id"`
	LoanDate          time.Time       `json:"loan_date"`
	DueDate           time.Time       `json:"due_date"`
	ReturnDate        *time.Time      `json:"return_date"`
	RenewalsCount     int             `json:"renewals_count"`
	Status            string          `json:"status"`
	FineAmount        decimal.Decimal `json:"fine_amount"`
	FinePaid          bool            `json:"fine_paid"`
	Comments          *string         `json:"comments"`
	ReturnLibrarianID *int            `json:"return_librarian_id"`
	CreatedAt         time.Time       `json:"created_at"`
	UpdatedAt         time.Time       `json:"updated_at"`
	Title             string          `json:"title"`
	Author            string          `json:"author"`
	ReaderName        string          `json:"reader_name"`
}

func (q *Queries) GetLoanByID(ctx context.Context, loanID int64) (*GetLoanByIDRow, error) {
	row := q.db.QueryRow(ctx, getLoanByID, loanID)
	var i GetLoanByIDRow
	err := row.Scan(
		&i.ID,
		&i.BookID,
		&i.ReaderID,
		&i.LibrarianID,
		&i.LoanDate,
		&i.DueDate,
		&i.ReturnDate,
		&i.RenewalsCount,
		&i.Status,
		&i.FineAmount,
		&i.FinePaid,
		&i.Comments,
		&i.ReturnLibrarianID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Title,
		&i.Author,
		&i.ReaderName,
	)
	return &i, err
}

const getOverdueBooks = `-- name: GetOverdueBooks :many
SELECT
    lh.id,
    b.title,
    b.author,
    b.book_code,
    r.full_name as reader_name,
    r.ticket_number,
    r.phone,
    r.email,
    lh.loan_date,
    lh.due_date,
    EXTRACT(DAYS FROM (CURRENT_DATE - lh.due_date))::int as days_overdue,
    CASE
        WHEN EXTRACT(DAYS FROM (CURRENT_DATE - lh.due_date)) <= 7 THEN 'Легкая'
        WHEN EXTRACT(DAYS FROM (CURRENT_DATE - lh.due_date)) <= 30 THEN 'Средняя'
        ELSE 'Критическая'
    END as overdue_level
FROM loan_history lh
JOIN books b ON lh.book_id = b.id
JOIN readers r ON lh.reader_id = r.id
WHERE lh.status = 'active' AND lh.due_date < CURRENT_DATE
ORDER BY days_overdue DESC
LIMIT $1
`

type GetOverdueBooksRow struct {
	ID           int64     `json:"id"`
	Title        string    `json:"title"`
	Author       string    `json:"author"`
	BookCode     string    `json:"book_code"`
	ReaderName   string    `json:"reader_name"`
	TicketNumber string    `json:"ticket_number"`
	Phone        *string   `json:"phone"`
	Email        *string   `json:"email"`
	LoanDate     time.Time `json:"loan_date"`
	DueDate      time.Time `json:"due_date"`
	DaysOverdue  int       `json:"days_overdue"`
	OverdueLevel string    `json:"overdue_level"`
}

func (q *Queries) GetOverdueBooks(ctx context.Context, resultLimit int32) ([]*GetOverdueBooksRow, error) {
	rows, err := q.db.Query(ctx, getOverdueBooks, resultLimit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetOverdueBooksRow{}
	for rows.Next() {
		var i GetOverdueBooksRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Author,
			&i.BookCode,
			&i.ReaderName,
			&i.TicketNumber,
			&i.Phone,
			&i.Email,
			&i.LoanDate,
			&i.DueDate,
			&i.DaysOverdue,
			&i.OverdueLevel,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getReaderCurrentLoans = `-- name: GetReaderCurrentLoans :many
SELECT b.title, b.author, b.book_code, lh.loan_date, lh.due_date,
       lh.renewals_count,
       EXTRACT(DAYS FROM (CURRENT_DATE - lh.due_date))::int as days_overdue,
       CASE WHEN lh.due_date < CURRENT_DATE THEN 'Просрочена' ELSE 'В срок' END as status_text
FROM loan_history lh
JOIN books b ON lh.book_id = b.id
WHERE lh.reader_id = $1 AND lh.status = 'active'
ORDER BY lh.due_date
`

type GetReaderCurrentLoansRow struct {
	Title         string    `json:"title"`
	Author        string    `json:"author"`
	BookCode      string    `json:"book_code"`
	LoanDate      time.Time `json:"loan_date"`
	DueDate       time.Time `json:"due_date"`
	RenewalsCount int       `json:"renewals_count"`
	DaysOverdue   int       `json:"days_overdue"`
	StatusText    string    `json:"status_text"`
}

func (q *Queries) GetReaderCurrentLoans(ctx context.Context, readerID int) ([]*GetReaderCurrentLoansRow, error) {
	rows, err := q.db.Query(ctx, getReaderCurrentLoans, readerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetReaderCurrentLoansRow{}
	for rows.Next() {
		var i GetReaderCurrentLoansRow
		if err := rows.Scan(
			&i.Title,
			&i.Author,
			&i.BookCode,
			&i.LoanDate,
			&i.DueDate,
			&i.RenewalsCount,
			&i.DaysOverdue,
			&i.StatusText,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getReaderLoanHistory = `-- name: GetReaderLoanHistory :many
SELECT b.title, b.author, lh.loan_date, lh.return_date, lh.due_date,
       lh.status, lh.renewals_count,
       CASE WHEN lh.return_date > lh.due_date
            THEN EXTRACT(DAYS FROM (lh.return_date - lh.due_date))::int
            ELSE 0 END as overdue_days
FROM loan_history lh
JOIN books b ON lh.book_id = b.id
WHERE lh.reader_id = $1
ORDER BY lh.loan_date DESC
LIMIT $3 OFFSET $2
`

type GetReaderLoanHistoryParams struct {
	ReaderID   int   `json:"reader_id"`
	PageOffset int32 `json:"page_offset"`
	PageLimit  int32 `json:"page_limit"`
}

type GetReaderLoanHistoryRow struct {
	Title         string     `json:"title"`
	Author        string     `json:"author"`
	LoanDate      time.Time  `json:"loan_date"`
	ReturnDate    *time.Time `json:"return_date"`
	DueDate       time.Time  `json:"due_date"`
	Status        string     `json:"status"`
	RenewalsCount int        `json:"renewals_count"`
	OverdueDays   int32      `json:"overdue_days"`
}

func (q *Queries) GetReaderLoanHistory(ctx context.Context, arg GetReaderLoanHistoryParams) ([]*GetReaderLoanHistoryRow, error) {
	rows, err := q.db.Query(ctx, getReaderLoanHistory, arg.ReaderID, arg.PageOffset, arg.PageLimit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetReaderLoanHistoryRow{}
	for rows.Next() {
		var i GetReaderLoanHistoryRow
		if err := rows.Scan(
			&i.Title,
			&i.Author,
			&i.LoanDate,
			&i.ReturnDate,
			&i.DueDate,
			&i.Status,
			&i.RenewalsCount,
			&i.OverdueDays,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const markLoanAsLost = `-- name: MarkLoanAsLost :exec
UPDATE loan_history
SET
    status = 'lost',
    updated_at = NOW()
WHERE id = $1
`

func (q *Queries) MarkLoanAsLost(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, markLoanAsLost, id)
	return err
}

const renewLoan = `-- name: RenewLoan :exec
UPDATE loan_history
SET due_date = due_date + INTERVAL '@extension_days days',
    renewals_count = renewals_count + 1,
    updated_at = NOW()
WHERE id = $1 AND status = 'active'
`

func (q *Queries) RenewLoan(ctx context.Context, loanID int64) error {
	_, err := q.db.Exec(ctx, renewLoan, loanID)
	return err
}

const returnBook = `-- name: ReturnBook :exec
UPDATE loan_history
SET status = 'returned',
    return_date = CURRENT_DATE,
    return_librarian_id = $1,
    updated_at = NOW()
WHERE id = $2 AND status = 'active'
`

type ReturnBookParams struct {
	LibrarianID *int  `json:"librarian_id"`
	LoanID      int64 `json:"loan_id"`
}

func (q *Queries) ReturnBook(ctx context.Context, arg ReturnBookParams) error {
	_, err := q.db.Exec(ctx, returnBook, arg.LibrarianID, arg.LoanID)
	return err
}
