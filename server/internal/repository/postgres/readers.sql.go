// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: readers.sql

package postgres

import (
	"context"
	"time"

	"github.com/google/uuid"
)

const checkReaderOverdueBooks = `-- name: CheckReaderOverdueBooks :one
SELECT COUNT(*) as overdue_books
FROM book_issues bi
WHERE bi.reader_id = $1
  AND bi.return_date IS NULL
  AND bi.due_date < CURRENT_DATE
`

func (q *Queries) CheckReaderOverdueBooks(ctx context.Context, readerID uuid.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, checkReaderOverdueBooks, readerID)
	var overdue_books int64
	err := row.Scan(&overdue_books)
	return overdue_books, err
}

const createReader = `-- name: CreateReader :one
INSERT INTO readers (ticket_number, full_name, email, phone)
VALUES ($1, $2, $3, $4)
RETURNING id, ticket_number, created_at
`

type CreateReaderParams struct {
	TicketNumber string  `json:"ticket_number"`
	FullName     string  `json:"full_name"`
	Email        *string `json:"email"`
	Phone        *string `json:"phone"`
}

type CreateReaderRow struct {
	ID           uuid.UUID  `json:"id"`
	TicketNumber string     `json:"ticket_number"`
	CreatedAt    *time.Time `json:"created_at"`
}

func (q *Queries) CreateReader(ctx context.Context, arg CreateReaderParams) (*CreateReaderRow, error) {
	row := q.db.QueryRow(ctx, createReader,
		arg.TicketNumber,
		arg.FullName,
		arg.Email,
		arg.Phone,
	)
	var i CreateReaderRow
	err := row.Scan(&i.ID, &i.TicketNumber, &i.CreatedAt)
	return &i, err
}

const deactivateReader = `-- name: DeactivateReader :exec
UPDATE readers
SET is_active = false
WHERE id = $1
`

func (q *Queries) DeactivateReader(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deactivateReader, id)
	return err
}

const getActiveReaders = `-- name: GetActiveReaders :many
SELECT id, ticket_number, full_name, email, phone, registration_date
FROM readers
WHERE is_active = true
ORDER BY full_name
`

type GetActiveReadersRow struct {
	ID               uuid.UUID  `json:"id"`
	TicketNumber     string     `json:"ticket_number"`
	FullName         string     `json:"full_name"`
	Email            *string    `json:"email"`
	Phone            *string    `json:"phone"`
	RegistrationDate *time.Time `json:"registration_date"`
}

func (q *Queries) GetActiveReaders(ctx context.Context) ([]*GetActiveReadersRow, error) {
	rows, err := q.db.Query(ctx, getActiveReaders)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetActiveReadersRow{}
	for rows.Next() {
		var i GetActiveReadersRow
		if err := rows.Scan(
			&i.ID,
			&i.TicketNumber,
			&i.FullName,
			&i.Email,
			&i.Phone,
			&i.RegistrationDate,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getReaderById = `-- name: GetReaderById :one
SELECT id, ticket_number, full_name, email, phone, is_active, registration_date
FROM readers
WHERE id = $1
`

type GetReaderByIdRow struct {
	ID               uuid.UUID  `json:"id"`
	TicketNumber     string     `json:"ticket_number"`
	FullName         string     `json:"full_name"`
	Email            *string    `json:"email"`
	Phone            *string    `json:"phone"`
	IsActive         *bool      `json:"is_active"`
	RegistrationDate *time.Time `json:"registration_date"`
}

func (q *Queries) GetReaderById(ctx context.Context, id uuid.UUID) (*GetReaderByIdRow, error) {
	row := q.db.QueryRow(ctx, getReaderById, id)
	var i GetReaderByIdRow
	err := row.Scan(
		&i.ID,
		&i.TicketNumber,
		&i.FullName,
		&i.Email,
		&i.Phone,
		&i.IsActive,
		&i.RegistrationDate,
	)
	return &i, err
}

const getReaderByTicketNumber = `-- name: GetReaderByTicketNumber :one
SELECT id, ticket_number, full_name, email, phone, is_active, registration_date
FROM readers
WHERE ticket_number = $1
`

type GetReaderByTicketNumberRow struct {
	ID               uuid.UUID  `json:"id"`
	TicketNumber     string     `json:"ticket_number"`
	FullName         string     `json:"full_name"`
	Email            *string    `json:"email"`
	Phone            *string    `json:"phone"`
	IsActive         *bool      `json:"is_active"`
	RegistrationDate *time.Time `json:"registration_date"`
}

func (q *Queries) GetReaderByTicketNumber(ctx context.Context, ticketNumber string) (*GetReaderByTicketNumberRow, error) {
	row := q.db.QueryRow(ctx, getReaderByTicketNumber, ticketNumber)
	var i GetReaderByTicketNumberRow
	err := row.Scan(
		&i.ID,
		&i.TicketNumber,
		&i.FullName,
		&i.Email,
		&i.Phone,
		&i.IsActive,
		&i.RegistrationDate,
	)
	return &i, err
}

const searchReaders = `-- name: SearchReaders :many
SELECT id, ticket_number, full_name, email, phone, is_active, registration_date
FROM readers
WHERE (full_name ILIKE '%' || $1 || '%'
    OR ticket_number ILIKE '%' || $1 || '%')
  AND ($2::boolean OR is_active = true)
ORDER BY full_name
`

type SearchReadersParams struct {
	SearchTerm      *string `json:"search_term"`
	IncludeInactive bool    `json:"include_inactive"`
}

type SearchReadersRow struct {
	ID               uuid.UUID  `json:"id"`
	TicketNumber     string     `json:"ticket_number"`
	FullName         string     `json:"full_name"`
	Email            *string    `json:"email"`
	Phone            *string    `json:"phone"`
	IsActive         *bool      `json:"is_active"`
	RegistrationDate *time.Time `json:"registration_date"`
}

func (q *Queries) SearchReaders(ctx context.Context, arg SearchReadersParams) ([]*SearchReadersRow, error) {
	rows, err := q.db.Query(ctx, searchReaders, arg.SearchTerm, arg.IncludeInactive)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*SearchReadersRow{}
	for rows.Next() {
		var i SearchReadersRow
		if err := rows.Scan(
			&i.ID,
			&i.TicketNumber,
			&i.FullName,
			&i.Email,
			&i.Phone,
			&i.IsActive,
			&i.RegistrationDate,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateReader = `-- name: UpdateReader :one
UPDATE readers
SET full_name = $1, email = $2, phone = $3
WHERE id = $4
RETURNING id, ticket_number, full_name, email, phone
`

type UpdateReaderParams struct {
	FullName string    `json:"full_name"`
	Email    *string   `json:"email"`
	Phone    *string   `json:"phone"`
	ID       uuid.UUID `json:"id"`
}

type UpdateReaderRow struct {
	ID           uuid.UUID `json:"id"`
	TicketNumber string    `json:"ticket_number"`
	FullName     string    `json:"full_name"`
	Email        *string   `json:"email"`
	Phone        *string   `json:"phone"`
}

func (q *Queries) UpdateReader(ctx context.Context, arg UpdateReaderParams) (*UpdateReaderRow, error) {
	row := q.db.QueryRow(ctx, updateReader,
		arg.FullName,
		arg.Email,
		arg.Phone,
		arg.ID,
	)
	var i UpdateReaderRow
	err := row.Scan(
		&i.ID,
		&i.TicketNumber,
		&i.FullName,
		&i.Email,
		&i.Phone,
	)
	return &i, err
}
