// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: renewals.sql

package postgres

import (
	"context"
	"time"
)

const createRenewalRecord = `-- name: CreateRenewalRecord :one
INSERT INTO renewals (
    loan_history_id, renewal_date, old_due_date, new_due_date, librarian_id, reason
) VALUES (
    $1, CURRENT_DATE, $2, $3, $4, $5
) RETURNING id, loan_history_id, renewal_date, old_due_date, new_due_date, librarian_id, reason, created_at
`

type CreateRenewalRecordParams struct {
	LoanHistoryID int       `json:"loan_history_id"`
	OldDueDate    time.Time `json:"old_due_date"`
	NewDueDate    time.Time `json:"new_due_date"`
	LibrarianID   int       `json:"librarian_id"`
	Reason        *string   `json:"reason"`
}

func (q *Queries) CreateRenewalRecord(ctx context.Context, arg CreateRenewalRecordParams) (*Renewal, error) {
	row := q.db.QueryRow(ctx, createRenewalRecord,
		arg.LoanHistoryID,
		arg.OldDueDate,
		arg.NewDueDate,
		arg.LibrarianID,
		arg.Reason,
	)
	var i Renewal
	err := row.Scan(
		&i.ID,
		&i.LoanHistoryID,
		&i.RenewalDate,
		&i.OldDueDate,
		&i.NewDueDate,
		&i.LibrarianID,
		&i.Reason,
		&i.CreatedAt,
	)
	return &i, err
}

const getMostRenewedBooks = `-- name: GetMostRenewedBooks :many
SELECT
    b.title,
    b.author,
    b.book_code,
    COUNT(r.id) as renewal_count
FROM renewals r
JOIN loan_history lh ON r.loan_history_id = lh.id
JOIN books b ON lh.book_id = b.id
WHERE r.renewal_date >= CURRENT_DATE - INTERVAL '@days_back days'
GROUP BY b.id, b.title, b.author, b.book_code
ORDER BY renewal_count DESC
LIMIT $1
`

type GetMostRenewedBooksRow struct {
	Title        string `json:"title"`
	Author       string `json:"author"`
	BookCode     string `json:"book_code"`
	RenewalCount int64  `json:"renewal_count"`
}

func (q *Queries) GetMostRenewedBooks(ctx context.Context, resultLimit int32) ([]*GetMostRenewedBooksRow, error) {
	rows, err := q.db.Query(ctx, getMostRenewedBooks, resultLimit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetMostRenewedBooksRow{}
	for rows.Next() {
		var i GetMostRenewedBooksRow
		if err := rows.Scan(
			&i.Title,
			&i.Author,
			&i.BookCode,
			&i.RenewalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRenewalsByDate = `-- name: GetRenewalsByDate :many
SELECT
    r.id, r.loan_history_id, r.renewal_date, r.old_due_date, r.new_due_date, r.librarian_id, r.reason, r.created_at,
    lh.book_id,
    b.title,
    b.author,
    rd.full_name as reader_name,
    lib.full_name as librarian_name
FROM renewals r
JOIN loan_history lh ON r.loan_history_id = lh.id
JOIN books b ON lh.book_id = b.id
JOIN readers rd ON lh.reader_id = rd.id
JOIN librarians lib ON r.librarian_id = lib.id
WHERE r.renewal_date BETWEEN $1 AND $2
ORDER BY r.renewal_date DESC
`

type GetRenewalsByDateParams struct {
	StartDate time.Time `json:"start_date"`
	EndDate   time.Time `json:"end_date"`
}

type GetRenewalsByDateRow struct {
	ID            int64     `json:"id"`
	LoanHistoryID int       `json:"loan_history_id"`
	RenewalDate   time.Time `json:"renewal_date"`
	OldDueDate    time.Time `json:"old_due_date"`
	NewDueDate    time.Time `json:"new_due_date"`
	LibrarianID   int       `json:"librarian_id"`
	Reason        *string   `json:"reason"`
	CreatedAt     time.Time `json:"created_at"`
	BookID        int       `json:"book_id"`
	Title         string    `json:"title"`
	Author        string    `json:"author"`
	ReaderName    string    `json:"reader_name"`
	LibrarianName string    `json:"librarian_name"`
}

func (q *Queries) GetRenewalsByDate(ctx context.Context, arg GetRenewalsByDateParams) ([]*GetRenewalsByDateRow, error) {
	rows, err := q.db.Query(ctx, getRenewalsByDate, arg.StartDate, arg.EndDate)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetRenewalsByDateRow{}
	for rows.Next() {
		var i GetRenewalsByDateRow
		if err := rows.Scan(
			&i.ID,
			&i.LoanHistoryID,
			&i.RenewalDate,
			&i.OldDueDate,
			&i.NewDueDate,
			&i.LibrarianID,
			&i.Reason,
			&i.CreatedAt,
			&i.BookID,
			&i.Title,
			&i.Author,
			&i.ReaderName,
			&i.LibrarianName,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRenewalsForLoan = `-- name: GetRenewalsForLoan :many
SELECT
    r.id, r.loan_history_id, r.renewal_date, r.old_due_date, r.new_due_date, r.librarian_id, r.reason, r.created_at,
    lib.full_name as librarian_name
FROM renewals r
JOIN librarians lib ON r.librarian_id = lib.id
WHERE r.loan_history_id = $1
ORDER BY r.renewal_date DESC
`

type GetRenewalsForLoanRow struct {
	ID            int64     `json:"id"`
	LoanHistoryID int       `json:"loan_history_id"`
	RenewalDate   time.Time `json:"renewal_date"`
	OldDueDate    time.Time `json:"old_due_date"`
	NewDueDate    time.Time `json:"new_due_date"`
	LibrarianID   int       `json:"librarian_id"`
	Reason        *string   `json:"reason"`
	CreatedAt     time.Time `json:"created_at"`
	LibrarianName string    `json:"librarian_name"`
}

func (q *Queries) GetRenewalsForLoan(ctx context.Context, loanHistoryID int) ([]*GetRenewalsForLoanRow, error) {
	rows, err := q.db.Query(ctx, getRenewalsForLoan, loanHistoryID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetRenewalsForLoanRow{}
	for rows.Next() {
		var i GetRenewalsForLoanRow
		if err := rows.Scan(
			&i.ID,
			&i.LoanHistoryID,
			&i.RenewalDate,
			&i.OldDueDate,
			&i.NewDueDate,
			&i.LibrarianID,
			&i.Reason,
			&i.CreatedAt,
			&i.LibrarianName,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
