// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: system_logs.sql

package postgres

import (
	"context"
	"net/netip"
	"time"

	"github.com/google/uuid"
)

const countSystemLogsByAction = `-- name: CountSystemLogsByAction :one
SELECT COUNT(*) FROM system_logs
WHERE action_type = $1
AND action_timestamp BETWEEN $2 AND $3
`

type CountSystemLogsByActionParams struct {
	ActionType    ActionType `json:"action_type"`
	FromTimestamp *time.Time `json:"from_timestamp"`
	ToTimestamp   *time.Time `json:"to_timestamp"`
}

func (q *Queries) CountSystemLogsByAction(ctx context.Context, arg CountSystemLogsByActionParams) (int64, error) {
	row := q.db.QueryRow(ctx, countSystemLogsByAction, arg.ActionType, arg.FromTimestamp, arg.ToTimestamp)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createSystemLog = `-- name: CreateSystemLog :exec
INSERT INTO system_logs (user_id, action_type, entity_type, entity_id, old_values, new_values, ip_address, user_agent, details)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)
`

type CreateSystemLogParams struct {
	UserID     *uuid.UUID  `json:"user_id"`
	ActionType ActionType  `json:"action_type"`
	EntityType *string     `json:"entity_type"`
	EntityID   *uuid.UUID  `json:"entity_id"`
	OldValues  []byte      `json:"old_values"`
	NewValues  []byte      `json:"new_values"`
	IpAddress  *netip.Addr `json:"ip_address"`
	UserAgent  *string     `json:"user_agent"`
	Details    *string     `json:"details"`
}

func (q *Queries) CreateSystemLog(ctx context.Context, arg CreateSystemLogParams) error {
	_, err := q.db.Exec(ctx, createSystemLog,
		arg.UserID,
		arg.ActionType,
		arg.EntityType,
		arg.EntityID,
		arg.OldValues,
		arg.NewValues,
		arg.IpAddress,
		arg.UserAgent,
		arg.Details,
	)
	return err
}

const getRecentSystemLogs = `-- name: GetRecentSystemLogs :many
SELECT
    sl.id, sl.user_id, sl.action_type, sl.entity_type, sl.entity_id, sl.old_values, sl.new_values, sl.ip_address, sl.user_agent, sl.action_timestamp, sl.details,
    u.username
FROM system_logs sl
LEFT JOIN users u ON sl.user_id = u.id
WHERE sl.action_timestamp >= $1
ORDER BY sl.action_timestamp DESC
LIMIT $3 OFFSET $2
`

type GetRecentSystemLogsParams struct {
	FromTimestamp *time.Time `json:"from_timestamp"`
	OffsetVal     int32      `json:"offset_val"`
	LimitVal      int32      `json:"limit_val"`
}

type GetRecentSystemLogsRow struct {
	ID              uuid.UUID   `json:"id"`
	UserID          *uuid.UUID  `json:"user_id"`
	ActionType      ActionType  `json:"action_type"`
	EntityType      *string     `json:"entity_type"`
	EntityID        *uuid.UUID  `json:"entity_id"`
	OldValues       []byte      `json:"old_values"`
	NewValues       []byte      `json:"new_values"`
	IpAddress       *netip.Addr `json:"ip_address"`
	UserAgent       *string     `json:"user_agent"`
	ActionTimestamp *time.Time  `json:"action_timestamp"`
	Details         *string     `json:"details"`
	Username        *string     `json:"username"`
}

func (q *Queries) GetRecentSystemLogs(ctx context.Context, arg GetRecentSystemLogsParams) ([]*GetRecentSystemLogsRow, error) {
	rows, err := q.db.Query(ctx, getRecentSystemLogs, arg.FromTimestamp, arg.OffsetVal, arg.LimitVal)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetRecentSystemLogsRow{}
	for rows.Next() {
		var i GetRecentSystemLogsRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.ActionType,
			&i.EntityType,
			&i.EntityID,
			&i.OldValues,
			&i.NewValues,
			&i.IpAddress,
			&i.UserAgent,
			&i.ActionTimestamp,
			&i.Details,
			&i.Username,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSystemLogByID = `-- name: GetSystemLogByID :one
SELECT
    sl.id, sl.user_id, sl.action_type, sl.entity_type, sl.entity_id, sl.old_values, sl.new_values, sl.ip_address, sl.user_agent, sl.action_timestamp, sl.details,
    u.username
FROM system_logs sl
LEFT JOIN users u ON sl.user_id = u.id
WHERE sl.id = $1
`

type GetSystemLogByIDRow struct {
	ID              uuid.UUID   `json:"id"`
	UserID          *uuid.UUID  `json:"user_id"`
	ActionType      ActionType  `json:"action_type"`
	EntityType      *string     `json:"entity_type"`
	EntityID        *uuid.UUID  `json:"entity_id"`
	OldValues       []byte      `json:"old_values"`
	NewValues       []byte      `json:"new_values"`
	IpAddress       *netip.Addr `json:"ip_address"`
	UserAgent       *string     `json:"user_agent"`
	ActionTimestamp *time.Time  `json:"action_timestamp"`
	Details         *string     `json:"details"`
	Username        *string     `json:"username"`
}

func (q *Queries) GetSystemLogByID(ctx context.Context, logID uuid.UUID) (*GetSystemLogByIDRow, error) {
	row := q.db.QueryRow(ctx, getSystemLogByID, logID)
	var i GetSystemLogByIDRow
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.ActionType,
		&i.EntityType,
		&i.EntityID,
		&i.OldValues,
		&i.NewValues,
		&i.IpAddress,
		&i.UserAgent,
		&i.ActionTimestamp,
		&i.Details,
		&i.Username,
	)
	return &i, err
}

const getSystemLogsByAction = `-- name: GetSystemLogsByAction :many
SELECT
    sl.id, sl.user_id, sl.action_type, sl.entity_type, sl.entity_id, sl.old_values, sl.new_values, sl.ip_address, sl.user_agent, sl.action_timestamp, sl.details,
    u.username
FROM system_logs sl
LEFT JOIN users u ON sl.user_id = u.id
WHERE sl.action_type = $1
ORDER BY sl.action_timestamp DESC
LIMIT $3 OFFSET $2
`

type GetSystemLogsByActionParams struct {
	ActionType ActionType `json:"action_type"`
	OffsetVal  int32      `json:"offset_val"`
	LimitVal   int32      `json:"limit_val"`
}

type GetSystemLogsByActionRow struct {
	ID              uuid.UUID   `json:"id"`
	UserID          *uuid.UUID  `json:"user_id"`
	ActionType      ActionType  `json:"action_type"`
	EntityType      *string     `json:"entity_type"`
	EntityID        *uuid.UUID  `json:"entity_id"`
	OldValues       []byte      `json:"old_values"`
	NewValues       []byte      `json:"new_values"`
	IpAddress       *netip.Addr `json:"ip_address"`
	UserAgent       *string     `json:"user_agent"`
	ActionTimestamp *time.Time  `json:"action_timestamp"`
	Details         *string     `json:"details"`
	Username        *string     `json:"username"`
}

func (q *Queries) GetSystemLogsByAction(ctx context.Context, arg GetSystemLogsByActionParams) ([]*GetSystemLogsByActionRow, error) {
	rows, err := q.db.Query(ctx, getSystemLogsByAction, arg.ActionType, arg.OffsetVal, arg.LimitVal)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetSystemLogsByActionRow{}
	for rows.Next() {
		var i GetSystemLogsByActionRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.ActionType,
			&i.EntityType,
			&i.EntityID,
			&i.OldValues,
			&i.NewValues,
			&i.IpAddress,
			&i.UserAgent,
			&i.ActionTimestamp,
			&i.Details,
			&i.Username,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSystemLogsByEntity = `-- name: GetSystemLogsByEntity :many
SELECT
    sl.id, sl.user_id, sl.action_type, sl.entity_type, sl.entity_id, sl.old_values, sl.new_values, sl.ip_address, sl.user_agent, sl.action_timestamp, sl.details,
    u.username
FROM system_logs sl
LEFT JOIN users u ON sl.user_id = u.id
WHERE sl.entity_type = $1 AND sl.entity_id = $2
ORDER BY sl.action_timestamp DESC
`

type GetSystemLogsByEntityParams struct {
	EntityType *string    `json:"entity_type"`
	EntityID   *uuid.UUID `json:"entity_id"`
}

type GetSystemLogsByEntityRow struct {
	ID              uuid.UUID   `json:"id"`
	UserID          *uuid.UUID  `json:"user_id"`
	ActionType      ActionType  `json:"action_type"`
	EntityType      *string     `json:"entity_type"`
	EntityID        *uuid.UUID  `json:"entity_id"`
	OldValues       []byte      `json:"old_values"`
	NewValues       []byte      `json:"new_values"`
	IpAddress       *netip.Addr `json:"ip_address"`
	UserAgent       *string     `json:"user_agent"`
	ActionTimestamp *time.Time  `json:"action_timestamp"`
	Details         *string     `json:"details"`
	Username        *string     `json:"username"`
}

func (q *Queries) GetSystemLogsByEntity(ctx context.Context, arg GetSystemLogsByEntityParams) ([]*GetSystemLogsByEntityRow, error) {
	rows, err := q.db.Query(ctx, getSystemLogsByEntity, arg.EntityType, arg.EntityID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetSystemLogsByEntityRow{}
	for rows.Next() {
		var i GetSystemLogsByEntityRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.ActionType,
			&i.EntityType,
			&i.EntityID,
			&i.OldValues,
			&i.NewValues,
			&i.IpAddress,
			&i.UserAgent,
			&i.ActionTimestamp,
			&i.Details,
			&i.Username,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSystemLogsByUser = `-- name: GetSystemLogsByUser :many
SELECT
    sl.id, sl.user_id, sl.action_type, sl.entity_type, sl.entity_id, sl.old_values, sl.new_values, sl.ip_address, sl.user_agent, sl.action_timestamp, sl.details,
    u.username
FROM system_logs sl
LEFT JOIN users u ON sl.user_id = u.id
WHERE sl.user_id = $1
ORDER BY sl.action_timestamp DESC
LIMIT $3 OFFSET $2
`

type GetSystemLogsByUserParams struct {
	UserID    *uuid.UUID `json:"user_id"`
	OffsetVal int32      `json:"offset_val"`
	LimitVal  int32      `json:"limit_val"`
}

type GetSystemLogsByUserRow struct {
	ID              uuid.UUID   `json:"id"`
	UserID          *uuid.UUID  `json:"user_id"`
	ActionType      ActionType  `json:"action_type"`
	EntityType      *string     `json:"entity_type"`
	EntityID        *uuid.UUID  `json:"entity_id"`
	OldValues       []byte      `json:"old_values"`
	NewValues       []byte      `json:"new_values"`
	IpAddress       *netip.Addr `json:"ip_address"`
	UserAgent       *string     `json:"user_agent"`
	ActionTimestamp *time.Time  `json:"action_timestamp"`
	Details         *string     `json:"details"`
	Username        *string     `json:"username"`
}

func (q *Queries) GetSystemLogsByUser(ctx context.Context, arg GetSystemLogsByUserParams) ([]*GetSystemLogsByUserRow, error) {
	rows, err := q.db.Query(ctx, getSystemLogsByUser, arg.UserID, arg.OffsetVal, arg.LimitVal)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetSystemLogsByUserRow{}
	for rows.Next() {
		var i GetSystemLogsByUserRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.ActionType,
			&i.EntityType,
			&i.EntityID,
			&i.OldValues,
			&i.NewValues,
			&i.IpAddress,
			&i.UserAgent,
			&i.ActionTimestamp,
			&i.Details,
			&i.Username,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSystemLogsInDateRange = `-- name: GetSystemLogsInDateRange :many
SELECT
    sl.id, sl.user_id, sl.action_type, sl.entity_type, sl.entity_id, sl.old_values, sl.new_values, sl.ip_address, sl.user_agent, sl.action_timestamp, sl.details,
    u.username
FROM system_logs sl
LEFT JOIN users u ON sl.user_id = u.id
WHERE sl.action_timestamp BETWEEN $1 AND $2
ORDER BY sl.action_timestamp DESC
LIMIT $4 OFFSET $3
`

type GetSystemLogsInDateRangeParams struct {
	FromTimestamp *time.Time `json:"from_timestamp"`
	ToTimestamp   *time.Time `json:"to_timestamp"`
	OffsetVal     int32      `json:"offset_val"`
	LimitVal      int32      `json:"limit_val"`
}

type GetSystemLogsInDateRangeRow struct {
	ID              uuid.UUID   `json:"id"`
	UserID          *uuid.UUID  `json:"user_id"`
	ActionType      ActionType  `json:"action_type"`
	EntityType      *string     `json:"entity_type"`
	EntityID        *uuid.UUID  `json:"entity_id"`
	OldValues       []byte      `json:"old_values"`
	NewValues       []byte      `json:"new_values"`
	IpAddress       *netip.Addr `json:"ip_address"`
	UserAgent       *string     `json:"user_agent"`
	ActionTimestamp *time.Time  `json:"action_timestamp"`
	Details         *string     `json:"details"`
	Username        *string     `json:"username"`
}

func (q *Queries) GetSystemLogsInDateRange(ctx context.Context, arg GetSystemLogsInDateRangeParams) ([]*GetSystemLogsInDateRangeRow, error) {
	rows, err := q.db.Query(ctx, getSystemLogsInDateRange,
		arg.FromTimestamp,
		arg.ToTimestamp,
		arg.OffsetVal,
		arg.LimitVal,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetSystemLogsInDateRangeRow{}
	for rows.Next() {
		var i GetSystemLogsInDateRangeRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.ActionType,
			&i.EntityType,
			&i.EntityID,
			&i.OldValues,
			&i.NewValues,
			&i.IpAddress,
			&i.UserAgent,
			&i.ActionTimestamp,
			&i.Details,
			&i.Username,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSystemLogsStatistics = `-- name: GetSystemLogsStatistics :one
SELECT
    COUNT(*) as total_logs,
    COUNT(DISTINCT user_id) as unique_users,
    COUNT(CASE WHEN action_type = 'login' THEN 1 END) as login_count,
    COUNT(CASE WHEN action_type = 'book_issue' THEN 1 END) as book_issue_count,
    COUNT(CASE WHEN action_type = 'book_return' THEN 1 END) as book_return_count
FROM system_logs
WHERE action_timestamp BETWEEN $1 AND $2
`

type GetSystemLogsStatisticsParams struct {
	FromTimestamp *time.Time `json:"from_timestamp"`
	ToTimestamp   *time.Time `json:"to_timestamp"`
}

type GetSystemLogsStatisticsRow struct {
	TotalLogs       int64 `json:"total_logs"`
	UniqueUsers     int64 `json:"unique_users"`
	LoginCount      int64 `json:"login_count"`
	BookIssueCount  int64 `json:"book_issue_count"`
	BookReturnCount int64 `json:"book_return_count"`
}

func (q *Queries) GetSystemLogsStatistics(ctx context.Context, arg GetSystemLogsStatisticsParams) (*GetSystemLogsStatisticsRow, error) {
	row := q.db.QueryRow(ctx, getSystemLogsStatistics, arg.FromTimestamp, arg.ToTimestamp)
	var i GetSystemLogsStatisticsRow
	err := row.Scan(
		&i.TotalLogs,
		&i.UniqueUsers,
		&i.LoginCount,
		&i.BookIssueCount,
		&i.BookReturnCount,
	)
	return &i, err
}
