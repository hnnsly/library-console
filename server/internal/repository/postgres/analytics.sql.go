// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: analytics.sql

package postgres

import (
	"context"
	"time"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const getActiveReaderStatistics = `-- name: GetActiveReaderStatistics :many
SELECT
    r.id,
    r.full_name,
    r.ticket_number,
    rh.hall_name,
    COUNT(bi.id) as active_books,
    COUNT(CASE WHEN bi.due_date < CURRENT_DATE THEN 1 END) as overdue_books,
    COALESCE(SUM(f.amount - f.paid_amount), 0) as total_debt
FROM readers r
LEFT JOIN reading_halls rh ON r.reading_hall_id = rh.id
LEFT JOIN book_issues bi ON r.id = bi.reader_id AND bi.return_date IS NULL
LEFT JOIN fines f ON r.id = f.reader_id AND f.is_paid = false
WHERE r.is_active = true
GROUP BY r.id, r.full_name, r.ticket_number, rh.hall_name
HAVING COUNT(bi.id) > 0 OR COALESCE(SUM(f.amount - f.paid_amount), 0) > 0
ORDER BY COUNT(bi.id) DESC, total_debt DESC
`

type GetActiveReaderStatisticsRow struct {
	ID           uuid.UUID   `json:"id"`
	FullName     string      `json:"full_name"`
	TicketNumber string      `json:"ticket_number"`
	HallName     *string     `json:"hall_name"`
	ActiveBooks  int64       `json:"active_books"`
	OverdueBooks int64       `json:"overdue_books"`
	TotalDebt    interface{} `json:"total_debt"`
}

func (q *Queries) GetActiveReaderStatistics(ctx context.Context) ([]*GetActiveReaderStatisticsRow, error) {
	rows, err := q.db.Query(ctx, getActiveReaderStatistics)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetActiveReaderStatisticsRow{}
	for rows.Next() {
		var i GetActiveReaderStatisticsRow
		if err := rows.Scan(
			&i.ID,
			&i.FullName,
			&i.TicketNumber,
			&i.HallName,
			&i.ActiveBooks,
			&i.OverdueBooks,
			&i.TotalDebt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getBooksByAuthorInHall = `-- name: GetBooksByAuthorInHall :many
SELECT
    b.id,
    b.title,
    bc.copy_code,
    bc.status,
    rh.hall_name
FROM books b
JOIN book_authors ba ON b.id = ba.book_id
JOIN authors a ON ba.author_id = a.id
JOIN book_copies bc ON b.id = bc.book_id
LEFT JOIN reading_halls rh ON bc.reading_hall_id = rh.id
WHERE a.id = $1
AND ($2::uuid IS NULL OR bc.reading_hall_id = $2)
ORDER BY b.title, bc.copy_code
`

type GetBooksByAuthorInHallParams struct {
	AuthorID uuid.UUID `json:"author_id"`
	HallID   uuid.UUID `json:"hall_id"`
}

type GetBooksByAuthorInHallRow struct {
	ID       uuid.UUID      `json:"id"`
	Title    string         `json:"title"`
	CopyCode string         `json:"copy_code"`
	Status   NullBookStatus `json:"status"`
	HallName *string        `json:"hall_name"`
}

func (q *Queries) GetBooksByAuthorInHall(ctx context.Context, arg GetBooksByAuthorInHallParams) ([]*GetBooksByAuthorInHallRow, error) {
	rows, err := q.db.Query(ctx, getBooksByAuthorInHall, arg.AuthorID, arg.HallID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetBooksByAuthorInHallRow{}
	for rows.Next() {
		var i GetBooksByAuthorInHallRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.CopyCode,
			&i.Status,
			&i.HallName,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getHallUtilizationReport = `-- name: GetHallUtilizationReport :many
SELECT
    rh.id,
    rh.hall_name,
    rh.total_seats,
    rh.occupied_seats,
    COUNT(bc.id) as books_in_hall,
    COUNT(CASE WHEN bc.status = 'available' THEN 1 END) as available_books,
    COUNT(r.id) as registered_readers,
    COUNT(CASE WHEN r.is_active THEN 1 END) as active_readers
FROM reading_halls rh
LEFT JOIN book_copies bc ON rh.id = bc.reading_hall_id
LEFT JOIN readers r ON rh.id = r.reading_hall_id
GROUP BY rh.id, rh.hall_name, rh.total_seats, rh.occupied_seats
ORDER BY rh.hall_name
`

type GetHallUtilizationReportRow struct {
	ID                uuid.UUID `json:"id"`
	HallName          string    `json:"hall_name"`
	TotalSeats        int       `json:"total_seats"`
	OccupiedSeats     *int      `json:"occupied_seats"`
	BooksInHall       int64     `json:"books_in_hall"`
	AvailableBooks    int64     `json:"available_books"`
	RegisteredReaders int64     `json:"registered_readers"`
	ActiveReaders     int64     `json:"active_readers"`
}

func (q *Queries) GetHallUtilizationReport(ctx context.Context) ([]*GetHallUtilizationReportRow, error) {
	rows, err := q.db.Query(ctx, getHallUtilizationReport)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetHallUtilizationReportRow{}
	for rows.Next() {
		var i GetHallUtilizationReportRow
		if err := rows.Scan(
			&i.ID,
			&i.HallName,
			&i.TotalSeats,
			&i.OccupiedSeats,
			&i.BooksInHall,
			&i.AvailableBooks,
			&i.RegisteredReaders,
			&i.ActiveReaders,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLibraryStatistics = `-- name: GetLibraryStatistics :one
SELECT
    (SELECT COUNT(*) FROM books) as total_books,
    (SELECT COUNT(*) FROM book_copies) as total_copies,
    (SELECT COUNT(*) FROM book_copies WHERE status = 'available') as available_copies,
    (SELECT COUNT(*) FROM readers WHERE is_active = true) as active_readers,
    (SELECT COUNT(*) FROM book_issues WHERE return_date IS NULL) as active_issues,
    (SELECT COUNT(*) FROM book_issues WHERE return_date IS NULL AND due_date < CURRENT_DATE) as overdue_issues,
    (SELECT COUNT(*) FROM fines WHERE is_paid = false) as unpaid_fines,
    (SELECT COALESCE(SUM(amount - paid_amount), 0) FROM fines WHERE is_paid = false) as total_debt
`

type GetLibraryStatisticsRow struct {
	TotalBooks      int64       `json:"total_books"`
	TotalCopies     int64       `json:"total_copies"`
	AvailableCopies int64       `json:"available_copies"`
	ActiveReaders   int64       `json:"active_readers"`
	ActiveIssues    int64       `json:"active_issues"`
	OverdueIssues   int64       `json:"overdue_issues"`
	UnpaidFines     int64       `json:"unpaid_fines"`
	TotalDebt       interface{} `json:"total_debt"`
}

func (q *Queries) GetLibraryStatistics(ctx context.Context) (*GetLibraryStatisticsRow, error) {
	row := q.db.QueryRow(ctx, getLibraryStatistics)
	var i GetLibraryStatisticsRow
	err := row.Scan(
		&i.TotalBooks,
		&i.TotalCopies,
		&i.AvailableCopies,
		&i.ActiveReaders,
		&i.ActiveIssues,
		&i.OverdueIssues,
		&i.UnpaidFines,
		&i.TotalDebt,
	)
	return &i, err
}

const getMonthlyStatistics = `-- name: GetMonthlyStatistics :many
SELECT
    DATE_TRUNC('month', bi.issue_date) as month,
    COUNT(*) as issues_count,
    COUNT(DISTINCT bi.reader_id) as unique_readers,
    COUNT(DISTINCT bc.book_id) as unique_books
FROM book_issues bi
JOIN book_copies bc ON bi.book_copy_id = bc.id
WHERE bi.issue_date >= $1 AND bi.issue_date <= $2
GROUP BY DATE_TRUNC('month', bi.issue_date)
ORDER BY month
`

type GetMonthlyStatisticsParams struct {
	FromDate *time.Time `json:"from_date"`
	ToDate   *time.Time `json:"to_date"`
}

type GetMonthlyStatisticsRow struct {
	Month         pgtype.Interval `json:"month"`
	IssuesCount   int64           `json:"issues_count"`
	UniqueReaders int64           `json:"unique_readers"`
	UniqueBooks   int64           `json:"unique_books"`
}

func (q *Queries) GetMonthlyStatistics(ctx context.Context, arg GetMonthlyStatisticsParams) ([]*GetMonthlyStatisticsRow, error) {
	rows, err := q.db.Query(ctx, getMonthlyStatistics, arg.FromDate, arg.ToDate)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetMonthlyStatisticsRow{}
	for rows.Next() {
		var i GetMonthlyStatisticsRow
		if err := rows.Scan(
			&i.Month,
			&i.IssuesCount,
			&i.UniqueReaders,
			&i.UniqueBooks,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPopularBooks = `-- name: GetPopularBooks :many
SELECT
    b.id,
    b.title,
    string_agg(a.full_name, ', ' ORDER BY a.full_name) as authors,
    COUNT(bi.id) as issue_count,
    COALESCE(ROUND(AVG(br.rating), 2), 0) as avg_rating
FROM books b
LEFT JOIN book_authors ba ON b.id = ba.book_id
LEFT JOIN authors a ON ba.author_id = a.id
LEFT JOIN book_copies bc ON b.id = bc.book_id
LEFT JOIN book_issues bi ON bc.id = bi.book_copy_id
LEFT JOIN book_ratings br ON b.id = br.book_id
GROUP BY b.id, b.title
ORDER BY COUNT(bi.id) DESC, AVG(br.rating) DESC NULLS LAST
LIMIT $1
`

type GetPopularBooksRow struct {
	ID         uuid.UUID   `json:"id"`
	Title      string      `json:"title"`
	Authors    []byte      `json:"authors"`
	IssueCount int64       `json:"issue_count"`
	AvgRating  interface{} `json:"avg_rating"`
}

func (q *Queries) GetPopularBooks(ctx context.Context, limitVal int32) ([]*GetPopularBooksRow, error) {
	rows, err := q.db.Query(ctx, getPopularBooks, limitVal)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetPopularBooksRow{}
	for rows.Next() {
		var i GetPopularBooksRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Authors,
			&i.IssueCount,
			&i.AvgRating,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getReadersWithSingleCopyBooks = `-- name: GetReadersWithSingleCopyBooks :many
SELECT DISTINCT
    r.id,
    r.full_name,
    r.ticket_number,
    b.title as book_title,
    bc.copy_code
FROM readers r
JOIN book_issues bi ON r.id = bi.reader_id
JOIN book_copies bc ON bi.book_copy_id = bc.id
JOIN books b ON bc.book_id = b.id
WHERE bi.return_date IS NULL
AND b.total_copies = 1
ORDER BY r.full_name, b.title
`

type GetReadersWithSingleCopyBooksRow struct {
	ID           uuid.UUID `json:"id"`
	FullName     string    `json:"full_name"`
	TicketNumber string    `json:"ticket_number"`
	BookTitle    string    `json:"book_title"`
	CopyCode     string    `json:"copy_code"`
}

func (q *Queries) GetReadersWithSingleCopyBooks(ctx context.Context) ([]*GetReadersWithSingleCopyBooksRow, error) {
	rows, err := q.db.Query(ctx, getReadersWithSingleCopyBooks)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetReadersWithSingleCopyBooksRow{}
	for rows.Next() {
		var i GetReadersWithSingleCopyBooksRow
		if err := rows.Scan(
			&i.ID,
			&i.FullName,
			&i.TicketNumber,
			&i.BookTitle,
			&i.CopyCode,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
