// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: search.sql

package postgres

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const advancedBookSearch = `-- name: AdvancedBookSearch :many
SELECT
    b.id,
    b.title,
    b.author,
    b.publication_year,
    b.book_code,
    b.isbn,
    c.name as category,
    h.name as hall,
    b.total_copies,
    b.available_copies,
    b.popularity_score,
    b.rating,
    CASE WHEN b.available_copies > 0 THEN 'Доступна' ELSE 'Недоступна' END as availability_status
FROM books b
LEFT JOIN book_categories c ON b.category_id = c.id
JOIN halls h ON b.hall_id = h.id
WHERE
    ($1::text = '' OR b.title ILIKE '%' || $1 || '%')
    AND ($2::text = '' OR b.author ILIKE '%' || $2 || '%')
    AND ($3::int = 0 OR b.publication_year = $3)
    AND ($4::int = 0 OR b.category_id = $4)
    AND ($5::int = 0 OR b.hall_id = $5)
    AND ($6::boolean = false OR b.available_copies > 0)
    AND b.status != 'lost'
ORDER BY
    CASE $7::text
        WHEN 'title' THEN b.title
        WHEN 'author' THEN b.author
        WHEN 'year' THEN b.publication_year::text
        WHEN 'popularity' THEN b.popularity_score::text
        ELSE b.title
    END
LIMIT $9 OFFSET $8
`

type AdvancedBookSearchParams struct {
	TitleFilter    string `json:"title_filter"`
	AuthorFilter   string `json:"author_filter"`
	YearFilter     int32  `json:"year_filter"`
	CategoryFilter int32  `json:"category_filter"`
	HallFilter     int32  `json:"hall_filter"`
	AvailableOnly  bool   `json:"available_only"`
	SortBy         string `json:"sort_by"`
	PageOffset     int32  `json:"page_offset"`
	PageLimit      int32  `json:"page_limit"`
}

type AdvancedBookSearchRow struct {
	ID                 int32          `json:"id"`
	Title              string         `json:"title"`
	Author             string         `json:"author"`
	PublicationYear    int32          `json:"publication_year"`
	BookCode           string         `json:"book_code"`
	Isbn               pgtype.Text    `json:"isbn"`
	Category           pgtype.Text    `json:"category"`
	Hall               string         `json:"hall"`
	TotalCopies        int32          `json:"total_copies"`
	AvailableCopies    int32          `json:"available_copies"`
	PopularityScore    pgtype.Int4    `json:"popularity_score"`
	Rating             pgtype.Numeric `json:"rating"`
	AvailabilityStatus string         `json:"availability_status"`
}

func (q *Queries) AdvancedBookSearch(ctx context.Context, arg AdvancedBookSearchParams) ([]*AdvancedBookSearchRow, error) {
	rows, err := q.db.Query(ctx, advancedBookSearch,
		arg.TitleFilter,
		arg.AuthorFilter,
		arg.YearFilter,
		arg.CategoryFilter,
		arg.HallFilter,
		arg.AvailableOnly,
		arg.SortBy,
		arg.PageOffset,
		arg.PageLimit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*AdvancedBookSearchRow
	for rows.Next() {
		var i AdvancedBookSearchRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Author,
			&i.PublicationYear,
			&i.BookCode,
			&i.Isbn,
			&i.Category,
			&i.Hall,
			&i.TotalCopies,
			&i.AvailableCopies,
			&i.PopularityScore,
			&i.Rating,
			&i.AvailabilityStatus,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const globalSearch = `-- name: GlobalSearch :many
(SELECT
    'book' as type,
    b.id,
    b.title as name,
    b.author as details,
    NULL as ticket
FROM books b
WHERE b.title ILIKE '%' || $1::text || '%'
   OR b.author ILIKE '%' || $1::text || '%')
UNION ALL
(SELECT
    'reader' as type,
    r.id,
    r.full_name as name,
    r.phone as details,
    r.ticket_number as ticket
FROM readers r
WHERE r.full_name ILIKE '%' || $1::text || '%'
   OR r.ticket_number ILIKE '%' || $1::text || '%')
ORDER BY name
LIMIT 20
`

type GlobalSearchRow struct {
	Type    string      `json:"type"`
	ID      int32       `json:"id"`
	Name    string      `json:"name"`
	Details string      `json:"details"`
	Ticket  interface{} `json:"ticket"`
}

func (q *Queries) GlobalSearch(ctx context.Context, searchTerm string) ([]*GlobalSearchRow, error) {
	rows, err := q.db.Query(ctx, globalSearch, searchTerm)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GlobalSearchRow
	for rows.Next() {
		var i GlobalSearchRow
		if err := rows.Scan(
			&i.Type,
			&i.ID,
			&i.Name,
			&i.Details,
			&i.Ticket,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
