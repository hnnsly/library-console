// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: reservations.sql

package postgres

import (
	"context"
	"time"
)

const cancelReservation = `-- name: CancelReservation :exec
UPDATE reservations
SET status = 'cancelled', updated_at = NOW()
WHERE id = $1
`

func (q *Queries) CancelReservation(ctx context.Context, reservationID int64) error {
	_, err := q.db.Exec(ctx, cancelReservation, reservationID)
	return err
}

const createReservation = `-- name: CreateReservation :one
INSERT INTO reservations (
    book_id, reader_id, reservation_date, expiration_date, priority_order
) VALUES (
    $1, $2, CURRENT_DATE, CURRENT_DATE + INTERVAL '7 days',
    (SELECT COALESCE(MAX(priority_order), 0) + 1 FROM reservations WHERE book_id = $1 AND status = 'active')
) RETURNING id, book_id, reader_id, reservation_date, expiration_date, status, priority_order, notification_sent, created_at, updated_at
`

type CreateReservationParams struct {
	BookID   int `json:"book_id"`
	ReaderID int `json:"reader_id"`
}

func (q *Queries) CreateReservation(ctx context.Context, arg CreateReservationParams) (*Reservation, error) {
	row := q.db.QueryRow(ctx, createReservation, arg.BookID, arg.ReaderID)
	var i Reservation
	err := row.Scan(
		&i.ID,
		&i.BookID,
		&i.ReaderID,
		&i.ReservationDate,
		&i.ExpirationDate,
		&i.Status,
		&i.PriorityOrder,
		&i.NotificationSent,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const fulfillReservation = `-- name: FulfillReservation :exec
UPDATE reservations
SET status = 'fulfilled', updated_at = NOW()
WHERE id = $1
`

func (q *Queries) FulfillReservation(ctx context.Context, reservationID int64) error {
	_, err := q.db.Exec(ctx, fulfillReservation, reservationID)
	return err
}

const getBookQueue = `-- name: GetBookQueue :many
SELECT
    r.full_name,
    r.ticket_number,
    res.reservation_date,
    res.priority_order,
    res.expiration_date
FROM reservations res
JOIN readers r ON res.reader_id = r.id
WHERE res.book_id = $1 AND res.status = 'active'
ORDER BY res.priority_order
`

type GetBookQueueRow struct {
	FullName        string    `json:"full_name"`
	TicketNumber    string    `json:"ticket_number"`
	ReservationDate time.Time `json:"reservation_date"`
	PriorityOrder   int       `json:"priority_order"`
	ExpirationDate  time.Time `json:"expiration_date"`
}

func (q *Queries) GetBookQueue(ctx context.Context, bookID int) ([]*GetBookQueueRow, error) {
	rows, err := q.db.Query(ctx, getBookQueue, bookID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetBookQueueRow{}
	for rows.Next() {
		var i GetBookQueueRow
		if err := rows.Scan(
			&i.FullName,
			&i.TicketNumber,
			&i.ReservationDate,
			&i.PriorityOrder,
			&i.ExpirationDate,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getExpiredReservations = `-- name: GetExpiredReservations :many
SELECT res.id, res.book_id, res.reader_id, res.reservation_date, res.expiration_date, res.status, res.priority_order, res.notification_sent, res.created_at, res.updated_at, r.full_name, b.title
FROM reservations res
JOIN readers r ON res.reader_id = r.id
JOIN books b ON res.book_id = b.id
WHERE res.status = 'active' AND res.expiration_date < CURRENT_DATE
`

type GetExpiredReservationsRow struct {
	ID               int64     `json:"id"`
	BookID           int       `json:"book_id"`
	ReaderID         int       `json:"reader_id"`
	ReservationDate  time.Time `json:"reservation_date"`
	ExpirationDate   time.Time `json:"expiration_date"`
	Status           string    `json:"status"`
	PriorityOrder    int       `json:"priority_order"`
	NotificationSent bool      `json:"notification_sent"`
	CreatedAt        time.Time `json:"created_at"`
	UpdatedAt        time.Time `json:"updated_at"`
	FullName         string    `json:"full_name"`
	Title            string    `json:"title"`
}

func (q *Queries) GetExpiredReservations(ctx context.Context) ([]*GetExpiredReservationsRow, error) {
	rows, err := q.db.Query(ctx, getExpiredReservations)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetExpiredReservationsRow{}
	for rows.Next() {
		var i GetExpiredReservationsRow
		if err := rows.Scan(
			&i.ID,
			&i.BookID,
			&i.ReaderID,
			&i.ReservationDate,
			&i.ExpirationDate,
			&i.Status,
			&i.PriorityOrder,
			&i.NotificationSent,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.FullName,
			&i.Title,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getReaderReservations = `-- name: GetReaderReservations :many
SELECT res.id, res.book_id, res.reader_id, res.reservation_date, res.expiration_date, res.status, res.priority_order, res.notification_sent, res.created_at, res.updated_at, b.title, b.author, b.book_code
FROM reservations res
JOIN books b ON res.book_id = b.id
WHERE res.reader_id = $1 AND res.status = 'active'
ORDER BY res.reservation_date DESC
`

type GetReaderReservationsRow struct {
	ID               int64     `json:"id"`
	BookID           int       `json:"book_id"`
	ReaderID         int       `json:"reader_id"`
	ReservationDate  time.Time `json:"reservation_date"`
	ExpirationDate   time.Time `json:"expiration_date"`
	Status           string    `json:"status"`
	PriorityOrder    int       `json:"priority_order"`
	NotificationSent bool      `json:"notification_sent"`
	CreatedAt        time.Time `json:"created_at"`
	UpdatedAt        time.Time `json:"updated_at"`
	Title            string    `json:"title"`
	Author           string    `json:"author"`
	BookCode         string    `json:"book_code"`
}

func (q *Queries) GetReaderReservations(ctx context.Context, readerID int) ([]*GetReaderReservationsRow, error) {
	rows, err := q.db.Query(ctx, getReaderReservations, readerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetReaderReservationsRow{}
	for rows.Next() {
		var i GetReaderReservationsRow
		if err := rows.Scan(
			&i.ID,
			&i.BookID,
			&i.ReaderID,
			&i.ReservationDate,
			&i.ExpirationDate,
			&i.Status,
			&i.PriorityOrder,
			&i.NotificationSent,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Title,
			&i.Author,
			&i.BookCode,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
