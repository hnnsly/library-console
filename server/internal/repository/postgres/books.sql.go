// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: books.sql

package postgres

import (
	"context"
	"time"

	"github.com/govalues/decimal"
)

const advancedSearchBooks = `-- name: AdvancedSearchBooks :many
SELECT
    b.id,
    b.title,
    b.author,
    b.publication_year,
    b.book_code,
    b.isbn,
    c.name as category,
    h.name as hall,
    b.total_copies,
    b.available_copies,
    b.popularity_score,
    b.rating,
    CASE WHEN b.available_copies > 0 THEN 'Доступна' ELSE 'Недоступна' END as availability_status
FROM books b
LEFT JOIN book_categories c ON b.category_id = c.id
JOIN halls h ON b.hall_id = h.id
WHERE
    ($1::text = '' OR b.title ILIKE '%' || $1 || '%')
    AND ($2::text = '' OR b.author ILIKE '%' || $2 || '%')
    AND ($3::int = 0 OR b.publication_year = $3)
    AND ($4::int = 0 OR b.category_id = $4)
    AND ($5::int = 0 OR b.hall_id = $5)
    AND ($6::boolean = false OR b.available_copies > 0)
    AND b.status != 'lost'
ORDER BY
    CASE $7::text
        WHEN 'title' THEN b.title
        WHEN 'author' THEN b.author
        WHEN 'year' THEN b.publication_year::text
        WHEN 'popularity' THEN b.popularity_score::text
        ELSE b.title
    END
LIMIT $9 OFFSET $8
`

type AdvancedSearchBooksParams struct {
	TitleFilter    string `json:"title_filter"`
	AuthorFilter   string `json:"author_filter"`
	YearFilter     int    `json:"year_filter"`
	CategoryFilter int    `json:"category_filter"`
	HallFilter     int    `json:"hall_filter"`
	AvailableOnly  bool   `json:"available_only"`
	SortBy         string `json:"sort_by"`
	PageOffset     int32  `json:"page_offset"`
	PageLimit      int32  `json:"page_limit"`
}

type AdvancedSearchBooksRow struct {
	ID                 int64           `json:"id"`
	Title              string          `json:"title"`
	Author             string          `json:"author"`
	PublicationYear    int             `json:"publication_year"`
	BookCode           string          `json:"book_code"`
	Isbn               *string         `json:"isbn"`
	Category           *string         `json:"category"`
	Hall               string          `json:"hall"`
	TotalCopies        int             `json:"total_copies"`
	AvailableCopies    int             `json:"available_copies"`
	PopularityScore    int             `json:"popularity_score"`
	Rating             decimal.Decimal `json:"rating"`
	AvailabilityStatus string          `json:"availability_status"`
}

func (q *Queries) AdvancedSearchBooks(ctx context.Context, arg AdvancedSearchBooksParams) ([]*AdvancedSearchBooksRow, error) {
	rows, err := q.db.Query(ctx, advancedSearchBooks,
		arg.TitleFilter,
		arg.AuthorFilter,
		arg.YearFilter,
		arg.CategoryFilter,
		arg.HallFilter,
		arg.AvailableOnly,
		arg.SortBy,
		arg.PageOffset,
		arg.PageLimit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*AdvancedSearchBooksRow{}
	for rows.Next() {
		var i AdvancedSearchBooksRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Author,
			&i.PublicationYear,
			&i.BookCode,
			&i.Isbn,
			&i.Category,
			&i.Hall,
			&i.TotalCopies,
			&i.AvailableCopies,
			&i.PopularityScore,
			&i.Rating,
			&i.AvailabilityStatus,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const createBook = `-- name: CreateBook :one
INSERT INTO books (
    title, author, publication_year, isbn, book_code,
    category_id, hall_id, total_copies, available_copies,
    condition_status, location_info, acquisition_date
) VALUES (
    $1, $2, $3, $4, $5,
    $6, $7, $8, $9,
    $10, $11, CURRENT_DATE
) RETURNING id, title, author, publication_year, isbn, book_code, category_id, hall_id, total_copies, available_copies, condition_status, location_info, max_loan_days, max_renewals, popularity_score, rating, acquisition_date, status, created_at, updated_at
`

type CreateBookParams struct {
	Title           string  `json:"title"`
	Author          string  `json:"author"`
	PublicationYear int     `json:"publication_year"`
	Isbn            *string `json:"isbn"`
	BookCode        string  `json:"book_code"`
	CategoryID      *int    `json:"category_id"`
	HallID          int     `json:"hall_id"`
	TotalCopies     int     `json:"total_copies"`
	AvailableCopies int     `json:"available_copies"`
	ConditionStatus string  `json:"condition_status"`
	LocationInfo    *string `json:"location_info"`
}

func (q *Queries) CreateBook(ctx context.Context, arg CreateBookParams) (*Book, error) {
	row := q.db.QueryRow(ctx, createBook,
		arg.Title,
		arg.Author,
		arg.PublicationYear,
		arg.Isbn,
		arg.BookCode,
		arg.CategoryID,
		arg.HallID,
		arg.TotalCopies,
		arg.AvailableCopies,
		arg.ConditionStatus,
		arg.LocationInfo,
	)
	var i Book
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Author,
		&i.PublicationYear,
		&i.Isbn,
		&i.BookCode,
		&i.CategoryID,
		&i.HallID,
		&i.TotalCopies,
		&i.AvailableCopies,
		&i.ConditionStatus,
		&i.LocationInfo,
		&i.MaxLoanDays,
		&i.MaxRenewals,
		&i.PopularityScore,
		&i.Rating,
		&i.AcquisitionDate,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const getAvailableBooks = `-- name: GetAvailableBooks :many
SELECT b.id, b.title, b.author, b.publication_year, b.isbn, b.book_code, b.category_id, b.hall_id, b.total_copies, b.available_copies, b.condition_status, b.location_info, b.max_loan_days, b.max_renewals, b.popularity_score, b.rating, b.acquisition_date, b.status, b.created_at, b.updated_at, c.name as category_name, h.name as hall_name
FROM books b
LEFT JOIN book_categories c ON b.category_id = c.id
JOIN halls h ON b.hall_id = h.id
WHERE b.available_copies > 0 AND b.status = 'available'
ORDER BY b.popularity_score DESC
LIMIT $1
`

type GetAvailableBooksRow struct {
	ID              int64           `json:"id"`
	Title           string          `json:"title"`
	Author          string          `json:"author"`
	PublicationYear int             `json:"publication_year"`
	Isbn            *string         `json:"isbn"`
	BookCode        string          `json:"book_code"`
	CategoryID      *int            `json:"category_id"`
	HallID          int             `json:"hall_id"`
	TotalCopies     int             `json:"total_copies"`
	AvailableCopies int             `json:"available_copies"`
	ConditionStatus string          `json:"condition_status"`
	LocationInfo    *string         `json:"location_info"`
	MaxLoanDays     int             `json:"max_loan_days"`
	MaxRenewals     int             `json:"max_renewals"`
	PopularityScore int             `json:"popularity_score"`
	Rating          decimal.Decimal `json:"rating"`
	AcquisitionDate time.Time       `json:"acquisition_date"`
	Status          string          `json:"status"`
	CreatedAt       time.Time       `json:"created_at"`
	UpdatedAt       time.Time       `json:"updated_at"`
	CategoryName    *string         `json:"category_name"`
	HallName        string          `json:"hall_name"`
}

func (q *Queries) GetAvailableBooks(ctx context.Context, resultLimit int32) ([]*GetAvailableBooksRow, error) {
	rows, err := q.db.Query(ctx, getAvailableBooks, resultLimit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetAvailableBooksRow{}
	for rows.Next() {
		var i GetAvailableBooksRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Author,
			&i.PublicationYear,
			&i.Isbn,
			&i.BookCode,
			&i.CategoryID,
			&i.HallID,
			&i.TotalCopies,
			&i.AvailableCopies,
			&i.ConditionStatus,
			&i.LocationInfo,
			&i.MaxLoanDays,
			&i.MaxRenewals,
			&i.PopularityScore,
			&i.Rating,
			&i.AcquisitionDate,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CategoryName,
			&i.HallName,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getBookByCode = `-- name: GetBookByCode :one
SELECT b.id, b.title, b.author, b.publication_year, b.isbn, b.book_code, b.category_id, b.hall_id, b.total_copies, b.available_copies, b.condition_status, b.location_info, b.max_loan_days, b.max_renewals, b.popularity_score, b.rating, b.acquisition_date, b.status, b.created_at, b.updated_at, c.name as category_name, h.name as hall_name
FROM books b
LEFT JOIN book_categories c ON b.category_id = c.id
JOIN halls h ON b.hall_id = h.id
WHERE b.book_code = $1
`

type GetBookByCodeRow struct {
	ID              int64           `json:"id"`
	Title           string          `json:"title"`
	Author          string          `json:"author"`
	PublicationYear int             `json:"publication_year"`
	Isbn            *string         `json:"isbn"`
	BookCode        string          `json:"book_code"`
	CategoryID      *int            `json:"category_id"`
	HallID          int             `json:"hall_id"`
	TotalCopies     int             `json:"total_copies"`
	AvailableCopies int             `json:"available_copies"`
	ConditionStatus string          `json:"condition_status"`
	LocationInfo    *string         `json:"location_info"`
	MaxLoanDays     int             `json:"max_loan_days"`
	MaxRenewals     int             `json:"max_renewals"`
	PopularityScore int             `json:"popularity_score"`
	Rating          decimal.Decimal `json:"rating"`
	AcquisitionDate time.Time       `json:"acquisition_date"`
	Status          string          `json:"status"`
	CreatedAt       time.Time       `json:"created_at"`
	UpdatedAt       time.Time       `json:"updated_at"`
	CategoryName    *string         `json:"category_name"`
	HallName        string          `json:"hall_name"`
}

func (q *Queries) GetBookByCode(ctx context.Context, bookCode string) (*GetBookByCodeRow, error) {
	row := q.db.QueryRow(ctx, getBookByCode, bookCode)
	var i GetBookByCodeRow
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Author,
		&i.PublicationYear,
		&i.Isbn,
		&i.BookCode,
		&i.CategoryID,
		&i.HallID,
		&i.TotalCopies,
		&i.AvailableCopies,
		&i.ConditionStatus,
		&i.LocationInfo,
		&i.MaxLoanDays,
		&i.MaxRenewals,
		&i.PopularityScore,
		&i.Rating,
		&i.AcquisitionDate,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CategoryName,
		&i.HallName,
	)
	return &i, err
}

const getBookByID = `-- name: GetBookByID :one
SELECT b.id, b.title, b.author, b.publication_year, b.isbn, b.book_code, b.category_id, b.hall_id, b.total_copies, b.available_copies, b.condition_status, b.location_info, b.max_loan_days, b.max_renewals, b.popularity_score, b.rating, b.acquisition_date, b.status, b.created_at, b.updated_at, c.name as category_name, h.name as hall_name
FROM books b
LEFT JOIN book_categories c ON b.category_id = c.id
JOIN halls h ON b.hall_id = h.id
WHERE b.id = $1
`

type GetBookByIDRow struct {
	ID              int64           `json:"id"`
	Title           string          `json:"title"`
	Author          string          `json:"author"`
	PublicationYear int             `json:"publication_year"`
	Isbn            *string         `json:"isbn"`
	BookCode        string          `json:"book_code"`
	CategoryID      *int            `json:"category_id"`
	HallID          int             `json:"hall_id"`
	TotalCopies     int             `json:"total_copies"`
	AvailableCopies int             `json:"available_copies"`
	ConditionStatus string          `json:"condition_status"`
	LocationInfo    *string         `json:"location_info"`
	MaxLoanDays     int             `json:"max_loan_days"`
	MaxRenewals     int             `json:"max_renewals"`
	PopularityScore int             `json:"popularity_score"`
	Rating          decimal.Decimal `json:"rating"`
	AcquisitionDate time.Time       `json:"acquisition_date"`
	Status          string          `json:"status"`
	CreatedAt       time.Time       `json:"created_at"`
	UpdatedAt       time.Time       `json:"updated_at"`
	CategoryName    *string         `json:"category_name"`
	HallName        string          `json:"hall_name"`
}

func (q *Queries) GetBookByID(ctx context.Context, bookID int64) (*GetBookByIDRow, error) {
	row := q.db.QueryRow(ctx, getBookByID, bookID)
	var i GetBookByIDRow
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Author,
		&i.PublicationYear,
		&i.Isbn,
		&i.BookCode,
		&i.CategoryID,
		&i.HallID,
		&i.TotalCopies,
		&i.AvailableCopies,
		&i.ConditionStatus,
		&i.LocationInfo,
		&i.MaxLoanDays,
		&i.MaxRenewals,
		&i.PopularityScore,
		&i.Rating,
		&i.AcquisitionDate,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CategoryName,
		&i.HallName,
	)
	return &i, err
}

const getBooksByAuthorInHall = `-- name: GetBooksByAuthorInHall :one
SELECT COUNT(*) as book_count,
       SUM(b.total_copies) as total_copies,
       SUM(b.available_copies) as available_copies
FROM books b
WHERE b.author ILIKE '%' || $1 || '%' AND b.hall_id = $2
`

type GetBooksByAuthorInHallParams struct {
	Author *string `json:"author"`
	HallID int     `json:"hall_id"`
}

type GetBooksByAuthorInHallRow struct {
	BookCount       int64 `json:"book_count"`
	TotalCopies     int64 `json:"total_copies"`
	AvailableCopies int64 `json:"available_copies"`
}

func (q *Queries) GetBooksByAuthorInHall(ctx context.Context, arg GetBooksByAuthorInHallParams) (*GetBooksByAuthorInHallRow, error) {
	row := q.db.QueryRow(ctx, getBooksByAuthorInHall, arg.Author, arg.HallID)
	var i GetBooksByAuthorInHallRow
	err := row.Scan(&i.BookCount, &i.TotalCopies, &i.AvailableCopies)
	return &i, err
}

const getBooksWithSingleCopy = `-- name: GetBooksWithSingleCopy :many
SELECT DISTINCT r.full_name, r.ticket_number, r.phone, b.title, b.author
FROM readers r
JOIN loan_history lh ON r.id = lh.reader_id
JOIN books b ON lh.book_id = b.id
WHERE lh.status = 'active' AND b.total_copies = 1
ORDER BY r.full_name
`

type GetBooksWithSingleCopyRow struct {
	FullName     string  `json:"full_name"`
	TicketNumber string  `json:"ticket_number"`
	Phone        *string `json:"phone"`
	Title        string  `json:"title"`
	Author       string  `json:"author"`
}

func (q *Queries) GetBooksWithSingleCopy(ctx context.Context) ([]*GetBooksWithSingleCopyRow, error) {
	rows, err := q.db.Query(ctx, getBooksWithSingleCopy)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetBooksWithSingleCopyRow{}
	for rows.Next() {
		var i GetBooksWithSingleCopyRow
		if err := rows.Scan(
			&i.FullName,
			&i.TicketNumber,
			&i.Phone,
			&i.Title,
			&i.Author,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPopularBooks = `-- name: GetPopularBooks :many
SELECT
    b.title,
    b.author,
    b.book_code,
    COUNT(lh.id) as loan_count,
    b.popularity_score,
    AVG(b.rating) as avg_rating
FROM books b
JOIN loan_history lh ON b.id = lh.book_id
WHERE lh.loan_date >= CURRENT_DATE - INTERVAL '@days_back days'
GROUP BY b.id, b.title, b.author, b.book_code, b.popularity_score
ORDER BY loan_count DESC
LIMIT $1
`

type GetPopularBooksRow struct {
	Title           string  `json:"title"`
	Author          string  `json:"author"`
	BookCode        string  `json:"book_code"`
	LoanCount       int64   `json:"loan_count"`
	PopularityScore int     `json:"popularity_score"`
	AvgRating       float64 `json:"avg_rating"`
}

func (q *Queries) GetPopularBooks(ctx context.Context, resultLimit int32) ([]*GetPopularBooksRow, error) {
	rows, err := q.db.Query(ctx, getPopularBooks, resultLimit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetPopularBooksRow{}
	for rows.Next() {
		var i GetPopularBooksRow
		if err := rows.Scan(
			&i.Title,
			&i.Author,
			&i.BookCode,
			&i.LoanCount,
			&i.PopularityScore,
			&i.AvgRating,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTopRatedBooks = `-- name: GetTopRatedBooks :many
SELECT title, author, rating, popularity_score, book_code
FROM books
WHERE rating = (SELECT MAX(rating) FROM books)
ORDER BY popularity_score DESC
LIMIT $1
`

type GetTopRatedBooksRow struct {
	Title           string          `json:"title"`
	Author          string          `json:"author"`
	Rating          decimal.Decimal `json:"rating"`
	PopularityScore int             `json:"popularity_score"`
	BookCode        string          `json:"book_code"`
}

func (q *Queries) GetTopRatedBooks(ctx context.Context, resultLimit int32) ([]*GetTopRatedBooksRow, error) {
	rows, err := q.db.Query(ctx, getTopRatedBooks, resultLimit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetTopRatedBooksRow{}
	for rows.Next() {
		var i GetTopRatedBooksRow
		if err := rows.Scan(
			&i.Title,
			&i.Author,
			&i.Rating,
			&i.PopularityScore,
			&i.BookCode,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchBooks = `-- name: SearchBooks :many
SELECT b.id, b.title, b.author, b.publication_year, b.isbn, b.book_code, b.category_id, b.hall_id, b.total_copies, b.available_copies, b.condition_status, b.location_info, b.max_loan_days, b.max_renewals, b.popularity_score, b.rating, b.acquisition_date, b.status, b.created_at, b.updated_at, c.name as category_name, h.name as hall_name
FROM books b
LEFT JOIN book_categories c ON b.category_id = c.id
JOIN halls h ON b.hall_id = h.id
WHERE
    ($1::text IS NULL OR b.title ILIKE '%' || $1 || '%')
    AND ($2::text IS NULL OR b.author ILIKE '%' || $2 || '%')
    AND ($3::text IS NULL OR b.book_code = $3)
    AND ($4::text IS NULL OR b.isbn = $4)
    AND ($5::int IS NULL OR b.category_id = $5)
    AND ($6::int IS NULL OR b.hall_id = $6)
    AND b.status != 'lost'
ORDER BY b.title
LIMIT $8 OFFSET $7
`

type SearchBooksParams struct {
	Title      string `json:"title"`
	Author     string `json:"author"`
	BookCode   string `json:"book_code"`
	Isbn       string `json:"isbn"`
	CategoryID int    `json:"category_id"`
	HallID     int    `json:"hall_id"`
	PageOffset int32  `json:"page_offset"`
	PageLimit  int32  `json:"page_limit"`
}

type SearchBooksRow struct {
	ID              int64           `json:"id"`
	Title           string          `json:"title"`
	Author          string          `json:"author"`
	PublicationYear int             `json:"publication_year"`
	Isbn            *string         `json:"isbn"`
	BookCode        string          `json:"book_code"`
	CategoryID      *int            `json:"category_id"`
	HallID          int             `json:"hall_id"`
	TotalCopies     int             `json:"total_copies"`
	AvailableCopies int             `json:"available_copies"`
	ConditionStatus string          `json:"condition_status"`
	LocationInfo    *string         `json:"location_info"`
	MaxLoanDays     int             `json:"max_loan_days"`
	MaxRenewals     int             `json:"max_renewals"`
	PopularityScore int             `json:"popularity_score"`
	Rating          decimal.Decimal `json:"rating"`
	AcquisitionDate time.Time       `json:"acquisition_date"`
	Status          string          `json:"status"`
	CreatedAt       time.Time       `json:"created_at"`
	UpdatedAt       time.Time       `json:"updated_at"`
	CategoryName    *string         `json:"category_name"`
	HallName        string          `json:"hall_name"`
}

func (q *Queries) SearchBooks(ctx context.Context, arg SearchBooksParams) ([]*SearchBooksRow, error) {
	rows, err := q.db.Query(ctx, searchBooks,
		arg.Title,
		arg.Author,
		arg.BookCode,
		arg.Isbn,
		arg.CategoryID,
		arg.HallID,
		arg.PageOffset,
		arg.PageLimit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*SearchBooksRow{}
	for rows.Next() {
		var i SearchBooksRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Author,
			&i.PublicationYear,
			&i.Isbn,
			&i.BookCode,
			&i.CategoryID,
			&i.HallID,
			&i.TotalCopies,
			&i.AvailableCopies,
			&i.ConditionStatus,
			&i.LocationInfo,
			&i.MaxLoanDays,
			&i.MaxRenewals,
			&i.PopularityScore,
			&i.Rating,
			&i.AcquisitionDate,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CategoryName,
			&i.HallName,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateBookAvailability = `-- name: UpdateBookAvailability :exec
UPDATE books
SET available_copies = $1,
    popularity_score = $2,
    updated_at = NOW()
WHERE id = $3
`

type UpdateBookAvailabilityParams struct {
	AvailableCopies int   `json:"available_copies"`
	PopularityScore int   `json:"popularity_score"`
	BookID          int64 `json:"book_id"`
}

func (q *Queries) UpdateBookAvailability(ctx context.Context, arg UpdateBookAvailabilityParams) error {
	_, err := q.db.Exec(ctx, updateBookAvailability, arg.AvailableCopies, arg.PopularityScore, arg.BookID)
	return err
}

const updateBookCopies = `-- name: UpdateBookCopies :exec
UPDATE books
SET total_copies = $1,
    available_copies = $2,
    updated_at = NOW()
WHERE id = $3
`

type UpdateBookCopiesParams struct {
	TotalCopies     int   `json:"total_copies"`
	AvailableCopies int   `json:"available_copies"`
	BookID          int64 `json:"book_id"`
}

func (q *Queries) UpdateBookCopies(ctx context.Context, arg UpdateBookCopiesParams) error {
	_, err := q.db.Exec(ctx, updateBookCopies, arg.TotalCopies, arg.AvailableCopies, arg.BookID)
	return err
}

const writeOffBook = `-- name: WriteOffBook :exec
UPDATE books
SET total_copies = total_copies - 1,
    available_copies = GREATEST(0, available_copies - 1),
    updated_at = NOW()
WHERE id = $1 AND total_copies > 0
`

func (q *Queries) WriteOffBook(ctx context.Context, bookID int64) error {
	_, err := q.db.Exec(ctx, writeOffBook, bookID)
	return err
}
