// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: books.sql

package postgres

import (
	"context"

	"github.com/google/uuid"
)

const createBook = `-- name: CreateBook :one
INSERT INTO books (title, isbn, publication_year, publisher, total_copies, available_copies)
VALUES ($1, $2, $3, $4, $5, $5)
RETURNING id, title, isbn, publication_year, publisher, total_copies, available_copies
`

type CreateBookParams struct {
	Title           string  `json:"title"`
	Isbn            *string `json:"isbn"`
	PublicationYear *int    `json:"publication_year"`
	Publisher       *string `json:"publisher"`
	TotalCopies     int     `json:"total_copies"`
}

type CreateBookRow struct {
	ID              uuid.UUID `json:"id"`
	Title           string    `json:"title"`
	Isbn            *string   `json:"isbn"`
	PublicationYear *int      `json:"publication_year"`
	Publisher       *string   `json:"publisher"`
	TotalCopies     int       `json:"total_copies"`
	AvailableCopies int       `json:"available_copies"`
}

func (q *Queries) CreateBook(ctx context.Context, arg CreateBookParams) (*CreateBookRow, error) {
	row := q.db.QueryRow(ctx, createBook,
		arg.Title,
		arg.Isbn,
		arg.PublicationYear,
		arg.Publisher,
		arg.TotalCopies,
	)
	var i CreateBookRow
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Isbn,
		&i.PublicationYear,
		&i.Publisher,
		&i.TotalCopies,
		&i.AvailableCopies,
	)
	return &i, err
}

const getAllBooks = `-- name: GetAllBooks :many
SELECT DISTINCT
    b.id,
    b.title,
    b.isbn,
    b.publication_year,
    b.publisher,
    b.available_copies,
    b.total_copies,
    STRING_AGG(a.full_name, ', ') as authors
FROM books b
LEFT JOIN book_authors ba ON b.id = ba.book_id
LEFT JOIN authors a ON ba.author_id = a.id
GROUP BY b.id, b.title, b.isbn, b.publication_year, b.publisher, b.available_copies, b.total_copies
ORDER BY b.title
`

type GetAllBooksRow struct {
	ID              uuid.UUID `json:"id"`
	Title           string    `json:"title"`
	Isbn            *string   `json:"isbn"`
	PublicationYear *int      `json:"publication_year"`
	Publisher       *string   `json:"publisher"`
	AvailableCopies int       `json:"available_copies"`
	TotalCopies     int       `json:"total_copies"`
	Authors         []byte    `json:"authors"`
}

func (q *Queries) GetAllBooks(ctx context.Context) ([]*GetAllBooksRow, error) {
	rows, err := q.db.Query(ctx, getAllBooks)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetAllBooksRow{}
	for rows.Next() {
		var i GetAllBooksRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Isbn,
			&i.PublicationYear,
			&i.Publisher,
			&i.AvailableCopies,
			&i.TotalCopies,
			&i.Authors,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getBookById = `-- name: GetBookById :one
SELECT id, title, isbn, publication_year, publisher, total_copies, available_copies
FROM books
WHERE id = $1
`

type GetBookByIdRow struct {
	ID              uuid.UUID `json:"id"`
	Title           string    `json:"title"`
	Isbn            *string   `json:"isbn"`
	PublicationYear *int      `json:"publication_year"`
	Publisher       *string   `json:"publisher"`
	TotalCopies     int       `json:"total_copies"`
	AvailableCopies int       `json:"available_copies"`
}

func (q *Queries) GetBookById(ctx context.Context, id uuid.UUID) (*GetBookByIdRow, error) {
	row := q.db.QueryRow(ctx, getBookById, id)
	var i GetBookByIdRow
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Isbn,
		&i.PublicationYear,
		&i.Publisher,
		&i.TotalCopies,
		&i.AvailableCopies,
	)
	return &i, err
}

const searchBooks = `-- name: SearchBooks :many
SELECT DISTINCT
    b.id,
    b.title,
    b.isbn,
    b.publication_year,
    b.publisher,
    b.available_copies,
    b.total_copies,
    STRING_AGG(a.full_name, ', ') as authors
FROM books b
LEFT JOIN book_authors ba ON b.id = ba.book_id
LEFT JOIN authors a ON ba.author_id = a.id
WHERE
    ($1::text IS NULL OR b.title ILIKE '%' || $1 || '%') AND
    ($2::text IS NULL OR a.full_name ILIKE '%' || $2 || '%') AND
    ($3::int IS NULL OR b.publication_year = $3)
GROUP BY b.id, b.title, b.isbn, b.publication_year, b.publisher, b.available_copies, b.total_copies
ORDER BY b.title
`

type SearchBooksParams struct {
	Title           string `json:"title"`
	Author          string `json:"author"`
	PublicationYear int    `json:"publication_year"`
}

type SearchBooksRow struct {
	ID              uuid.UUID `json:"id"`
	Title           string    `json:"title"`
	Isbn            *string   `json:"isbn"`
	PublicationYear *int      `json:"publication_year"`
	Publisher       *string   `json:"publisher"`
	AvailableCopies int       `json:"available_copies"`
	TotalCopies     int       `json:"total_copies"`
	Authors         []byte    `json:"authors"`
}

func (q *Queries) SearchBooks(ctx context.Context, arg SearchBooksParams) ([]*SearchBooksRow, error) {
	rows, err := q.db.Query(ctx, searchBooks, arg.Title, arg.Author, arg.PublicationYear)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*SearchBooksRow{}
	for rows.Next() {
		var i SearchBooksRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Isbn,
			&i.PublicationYear,
			&i.Publisher,
			&i.AvailableCopies,
			&i.TotalCopies,
			&i.Authors,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateBook = `-- name: UpdateBook :one
UPDATE books
SET title = $1, isbn = $2, publication_year = $3, publisher = $4
WHERE id = $5
RETURNING id, title, isbn, publication_year, publisher, total_copies, available_copies
`

type UpdateBookParams struct {
	Title           string    `json:"title"`
	Isbn            *string   `json:"isbn"`
	PublicationYear *int      `json:"publication_year"`
	Publisher       *string   `json:"publisher"`
	ID              uuid.UUID `json:"id"`
}

type UpdateBookRow struct {
	ID              uuid.UUID `json:"id"`
	Title           string    `json:"title"`
	Isbn            *string   `json:"isbn"`
	PublicationYear *int      `json:"publication_year"`
	Publisher       *string   `json:"publisher"`
	TotalCopies     int       `json:"total_copies"`
	AvailableCopies int       `json:"available_copies"`
}

func (q *Queries) UpdateBook(ctx context.Context, arg UpdateBookParams) (*UpdateBookRow, error) {
	row := q.db.QueryRow(ctx, updateBook,
		arg.Title,
		arg.Isbn,
		arg.PublicationYear,
		arg.Publisher,
		arg.ID,
	)
	var i UpdateBookRow
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Isbn,
		&i.PublicationYear,
		&i.Publisher,
		&i.TotalCopies,
		&i.AvailableCopies,
	)
	return &i, err
}

const updateBookCopies = `-- name: UpdateBookCopies :exec
UPDATE books
SET available_copies = available_copies + $1
WHERE id = $2
`

type UpdateBookCopiesParams struct {
	Change int       `json:"change"`
	BookID uuid.UUID `json:"book_id"`
}

func (q *Queries) UpdateBookCopies(ctx context.Context, arg UpdateBookCopiesParams) error {
	_, err := q.db.Exec(ctx, updateBookCopies, arg.Change, arg.BookID)
	return err
}
