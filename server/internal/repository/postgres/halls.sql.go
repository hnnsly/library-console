// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: halls.sql

package postgres

import (
	"context"

	"github.com/google/uuid"
)

const createReadingHall = `-- name: CreateReadingHall :one
INSERT INTO reading_halls (library_name, hall_name, specialization, total_seats)
VALUES ($1, $2, $3, $4)
RETURNING id, library_name, hall_name, specialization, total_seats, occupied_seats, created_at
`

type CreateReadingHallParams struct {
	LibraryName    string  `json:"library_name"`
	HallName       string  `json:"hall_name"`
	Specialization *string `json:"specialization"`
	TotalSeats     int     `json:"total_seats"`
}

func (q *Queries) CreateReadingHall(ctx context.Context, arg CreateReadingHallParams) (*ReadingHall, error) {
	row := q.db.QueryRow(ctx, createReadingHall,
		arg.LibraryName,
		arg.HallName,
		arg.Specialization,
		arg.TotalSeats,
	)
	var i ReadingHall
	err := row.Scan(
		&i.ID,
		&i.LibraryName,
		&i.HallName,
		&i.Specialization,
		&i.TotalSeats,
		&i.OccupiedSeats,
		&i.CreatedAt,
	)
	return &i, err
}

const deleteReadingHall = `-- name: DeleteReadingHall :exec
DELETE FROM reading_halls WHERE id = $1
`

func (q *Queries) DeleteReadingHall(ctx context.Context, hallID uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteReadingHall, hallID)
	return err
}

const getHallStatistics = `-- name: GetHallStatistics :many
SELECT
    rh.id,
    rh.library_name,
    rh.hall_name,
    rh.specialization,
    rh.total_seats,
    rh.occupied_seats,
    (rh.total_seats - rh.occupied_seats) as free_seats,
    COUNT(r.id) as registered_readers,
    COUNT(CASE WHEN r.is_active THEN 1 END) as active_readers
FROM reading_halls rh
LEFT JOIN readers r ON rh.id = r.reading_hall_id
GROUP BY rh.id, rh.library_name, rh.hall_name, rh.specialization, rh.total_seats, rh.occupied_seats
ORDER BY rh.library_name, rh.hall_name
`

type GetHallStatisticsRow struct {
	ID                uuid.UUID `json:"id"`
	LibraryName       string    `json:"library_name"`
	HallName          string    `json:"hall_name"`
	Specialization    *string   `json:"specialization"`
	TotalSeats        int       `json:"total_seats"`
	OccupiedSeats     *int      `json:"occupied_seats"`
	FreeSeats         int32     `json:"free_seats"`
	RegisteredReaders int64     `json:"registered_readers"`
	ActiveReaders     int64     `json:"active_readers"`
}

func (q *Queries) GetHallStatistics(ctx context.Context) ([]*GetHallStatisticsRow, error) {
	rows, err := q.db.Query(ctx, getHallStatistics)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetHallStatisticsRow{}
	for rows.Next() {
		var i GetHallStatisticsRow
		if err := rows.Scan(
			&i.ID,
			&i.LibraryName,
			&i.HallName,
			&i.Specialization,
			&i.TotalSeats,
			&i.OccupiedSeats,
			&i.FreeSeats,
			&i.RegisteredReaders,
			&i.ActiveReaders,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getReadingHallByID = `-- name: GetReadingHallByID :one
SELECT id, library_name, hall_name, specialization, total_seats, occupied_seats, created_at FROM reading_halls WHERE id = $1
`

func (q *Queries) GetReadingHallByID(ctx context.Context, hallID uuid.UUID) (*ReadingHall, error) {
	row := q.db.QueryRow(ctx, getReadingHallByID, hallID)
	var i ReadingHall
	err := row.Scan(
		&i.ID,
		&i.LibraryName,
		&i.HallName,
		&i.Specialization,
		&i.TotalSeats,
		&i.OccupiedSeats,
		&i.CreatedAt,
	)
	return &i, err
}

const listReadingHalls = `-- name: ListReadingHalls :many
SELECT id, library_name, hall_name, specialization, total_seats, occupied_seats, created_at FROM reading_halls ORDER BY library_name, hall_name
`

func (q *Queries) ListReadingHalls(ctx context.Context) ([]*ReadingHall, error) {
	rows, err := q.db.Query(ctx, listReadingHalls)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*ReadingHall{}
	for rows.Next() {
		var i ReadingHall
		if err := rows.Scan(
			&i.ID,
			&i.LibraryName,
			&i.HallName,
			&i.Specialization,
			&i.TotalSeats,
			&i.OccupiedSeats,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateHallOccupancy = `-- name: UpdateHallOccupancy :exec
UPDATE reading_halls
SET occupied_seats = $1
WHERE id = $2
`

type UpdateHallOccupancyParams struct {
	OccupiedSeats *int      `json:"occupied_seats"`
	HallID        uuid.UUID `json:"hall_id"`
}

func (q *Queries) UpdateHallOccupancy(ctx context.Context, arg UpdateHallOccupancyParams) error {
	_, err := q.db.Exec(ctx, updateHallOccupancy, arg.OccupiedSeats, arg.HallID)
	return err
}

const updateReadingHall = `-- name: UpdateReadingHall :one
UPDATE reading_halls
SET
    library_name = COALESCE($1, library_name),
    hall_name = COALESCE($2, hall_name),
    specialization = COALESCE($3, specialization),
    total_seats = COALESCE($4, total_seats),
    occupied_seats = COALESCE($5, occupied_seats)
WHERE id = $6
RETURNING id, library_name, hall_name, specialization, total_seats, occupied_seats, created_at
`

type UpdateReadingHallParams struct {
	LibraryName    string    `json:"library_name"`
	HallName       string    `json:"hall_name"`
	Specialization *string   `json:"specialization"`
	TotalSeats     int       `json:"total_seats"`
	OccupiedSeats  *int      `json:"occupied_seats"`
	HallID         uuid.UUID `json:"hall_id"`
}

func (q *Queries) UpdateReadingHall(ctx context.Context, arg UpdateReadingHallParams) (*ReadingHall, error) {
	row := q.db.QueryRow(ctx, updateReadingHall,
		arg.LibraryName,
		arg.HallName,
		arg.Specialization,
		arg.TotalSeats,
		arg.OccupiedSeats,
		arg.HallID,
	)
	var i ReadingHall
	err := row.Scan(
		&i.ID,
		&i.LibraryName,
		&i.HallName,
		&i.Specialization,
		&i.TotalSeats,
		&i.OccupiedSeats,
		&i.CreatedAt,
	)
	return &i, err
}
