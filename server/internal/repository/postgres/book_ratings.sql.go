// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: book_ratings.sql

package postgres

import (
	"context"
	"time"

	"github.com/google/uuid"
	"github.com/govalues/decimal"
)

const createBookRating = `-- name: CreateBookRating :one
INSERT INTO book_ratings (book_id, reader_id, rating, review, rating_date)
VALUES ($1, $2, $3, $4, $5)
ON CONFLICT (book_id, reader_id)
DO UPDATE SET
    rating = EXCLUDED.rating,
    review = EXCLUDED.review,
    rating_date = EXCLUDED.rating_date
RETURNING id, book_id, reader_id, rating, review, rating_date, created_at
`

type CreateBookRatingParams struct {
	BookID     uuid.UUID  `json:"book_id"`
	ReaderID   uuid.UUID  `json:"reader_id"`
	Rating     int        `json:"rating"`
	Review     *string    `json:"review"`
	RatingDate *time.Time `json:"rating_date"`
}

func (q *Queries) CreateBookRating(ctx context.Context, arg CreateBookRatingParams) (*BookRating, error) {
	row := q.db.QueryRow(ctx, createBookRating,
		arg.BookID,
		arg.ReaderID,
		arg.Rating,
		arg.Review,
		arg.RatingDate,
	)
	var i BookRating
	err := row.Scan(
		&i.ID,
		&i.BookID,
		&i.ReaderID,
		&i.Rating,
		&i.Review,
		&i.RatingDate,
		&i.CreatedAt,
	)
	return &i, err
}

const deleteBookRating = `-- name: DeleteBookRating :exec
DELETE FROM book_ratings WHERE id = $1
`

func (q *Queries) DeleteBookRating(ctx context.Context, ratingID uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteBookRating, ratingID)
	return err
}

const getBookAverageRating = `-- name: GetBookAverageRating :one
SELECT
    COALESCE(ROUND(AVG(rating), 2), 0) as avg_rating,
    COUNT(*) as total_ratings
FROM book_ratings
WHERE book_id = $1
`

type GetBookAverageRatingRow struct {
	AvgRating    interface{} `json:"avg_rating"`
	TotalRatings int64       `json:"total_ratings"`
}

func (q *Queries) GetBookAverageRating(ctx context.Context, bookID uuid.UUID) (*GetBookAverageRatingRow, error) {
	row := q.db.QueryRow(ctx, getBookAverageRating, bookID)
	var i GetBookAverageRatingRow
	err := row.Scan(&i.AvgRating, &i.TotalRatings)
	return &i, err
}

const getBookRatingByID = `-- name: GetBookRatingByID :one
SELECT
    br.id, br.book_id, br.reader_id, br.rating, br.review, br.rating_date, br.created_at,
    r.full_name as reader_name,
    b.title as book_title
FROM book_ratings br
JOIN readers r ON br.reader_id = r.id
JOIN books b ON br.book_id = b.id
WHERE br.id = $1
`

type GetBookRatingByIDRow struct {
	ID         uuid.UUID  `json:"id"`
	BookID     uuid.UUID  `json:"book_id"`
	ReaderID   uuid.UUID  `json:"reader_id"`
	Rating     int        `json:"rating"`
	Review     *string    `json:"review"`
	RatingDate *time.Time `json:"rating_date"`
	CreatedAt  *time.Time `json:"created_at"`
	ReaderName string     `json:"reader_name"`
	BookTitle  string     `json:"book_title"`
}

func (q *Queries) GetBookRatingByID(ctx context.Context, ratingID uuid.UUID) (*GetBookRatingByIDRow, error) {
	row := q.db.QueryRow(ctx, getBookRatingByID, ratingID)
	var i GetBookRatingByIDRow
	err := row.Scan(
		&i.ID,
		&i.BookID,
		&i.ReaderID,
		&i.Rating,
		&i.Review,
		&i.RatingDate,
		&i.CreatedAt,
		&i.ReaderName,
		&i.BookTitle,
	)
	return &i, err
}

const getBookRatings = `-- name: GetBookRatings :many
SELECT
    br.id, br.book_id, br.reader_id, br.rating, br.review, br.rating_date, br.created_at,
    r.full_name as reader_name
FROM book_ratings br
JOIN readers r ON br.reader_id = r.id
WHERE br.book_id = $1
ORDER BY br.rating_date DESC
`

type GetBookRatingsRow struct {
	ID         uuid.UUID  `json:"id"`
	BookID     uuid.UUID  `json:"book_id"`
	ReaderID   uuid.UUID  `json:"reader_id"`
	Rating     int        `json:"rating"`
	Review     *string    `json:"review"`
	RatingDate *time.Time `json:"rating_date"`
	CreatedAt  *time.Time `json:"created_at"`
	ReaderName string     `json:"reader_name"`
}

func (q *Queries) GetBookRatings(ctx context.Context, bookID uuid.UUID) ([]*GetBookRatingsRow, error) {
	rows, err := q.db.Query(ctx, getBookRatings, bookID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetBookRatingsRow{}
	for rows.Next() {
		var i GetBookRatingsRow
		if err := rows.Scan(
			&i.ID,
			&i.BookID,
			&i.ReaderID,
			&i.Rating,
			&i.Review,
			&i.RatingDate,
			&i.CreatedAt,
			&i.ReaderName,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getReaderBookRating = `-- name: GetReaderBookRating :one
SELECT id, book_id, reader_id, rating, review, rating_date, created_at FROM book_ratings
WHERE book_id = $1 AND reader_id = $2
`

type GetReaderBookRatingParams struct {
	BookID   uuid.UUID `json:"book_id"`
	ReaderID uuid.UUID `json:"reader_id"`
}

func (q *Queries) GetReaderBookRating(ctx context.Context, arg GetReaderBookRatingParams) (*BookRating, error) {
	row := q.db.QueryRow(ctx, getReaderBookRating, arg.BookID, arg.ReaderID)
	var i BookRating
	err := row.Scan(
		&i.ID,
		&i.BookID,
		&i.ReaderID,
		&i.Rating,
		&i.Review,
		&i.RatingDate,
		&i.CreatedAt,
	)
	return &i, err
}

const getReaderRatings = `-- name: GetReaderRatings :many
SELECT
    br.id, br.book_id, br.reader_id, br.rating, br.review, br.rating_date, br.created_at,
    b.title as book_title
FROM book_ratings br
JOIN books b ON br.book_id = b.id
WHERE br.reader_id = $1
ORDER BY br.rating_date DESC
`

type GetReaderRatingsRow struct {
	ID         uuid.UUID  `json:"id"`
	BookID     uuid.UUID  `json:"book_id"`
	ReaderID   uuid.UUID  `json:"reader_id"`
	Rating     int        `json:"rating"`
	Review     *string    `json:"review"`
	RatingDate *time.Time `json:"rating_date"`
	CreatedAt  *time.Time `json:"created_at"`
	BookTitle  string     `json:"book_title"`
}

func (q *Queries) GetReaderRatings(ctx context.Context, readerID uuid.UUID) ([]*GetReaderRatingsRow, error) {
	rows, err := q.db.Query(ctx, getReaderRatings, readerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetReaderRatingsRow{}
	for rows.Next() {
		var i GetReaderRatingsRow
		if err := rows.Scan(
			&i.ID,
			&i.BookID,
			&i.ReaderID,
			&i.Rating,
			&i.Review,
			&i.RatingDate,
			&i.CreatedAt,
			&i.BookTitle,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTopRatedBooksWithRatings = `-- name: GetTopRatedBooksWithRatings :many
SELECT
    b.id,
    b.title,
    string_agg(a.full_name, ', ' ORDER BY a.full_name) as authors,
    ROUND(AVG(br.rating), 2) as avg_rating,
    COUNT(br.rating) as rating_count
FROM books b
LEFT JOIN book_authors ba ON b.id = ba.book_id
LEFT JOIN authors a ON ba.author_id = a.id
JOIN book_ratings br ON b.id = br.book_id
GROUP BY b.id, b.title
HAVING COUNT(br.rating) >= $1
ORDER BY AVG(br.rating) DESC, COUNT(br.rating) DESC
LIMIT $2
`

type GetTopRatedBooksWithRatingsParams struct {
	MinRatings int   `json:"min_ratings"`
	LimitVal   int32 `json:"limit_val"`
}

type GetTopRatedBooksWithRatingsRow struct {
	ID          uuid.UUID       `json:"id"`
	Title       string          `json:"title"`
	Authors     []byte          `json:"authors"`
	AvgRating   decimal.Decimal `json:"avg_rating"`
	RatingCount int64           `json:"rating_count"`
}

func (q *Queries) GetTopRatedBooksWithRatings(ctx context.Context, arg GetTopRatedBooksWithRatingsParams) ([]*GetTopRatedBooksWithRatingsRow, error) {
	rows, err := q.db.Query(ctx, getTopRatedBooksWithRatings, arg.MinRatings, arg.LimitVal)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetTopRatedBooksWithRatingsRow{}
	for rows.Next() {
		var i GetTopRatedBooksWithRatingsRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Authors,
			&i.AvgRating,
			&i.RatingCount,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateBookRating = `-- name: UpdateBookRating :one
UPDATE book_ratings
SET
    rating = COALESCE($1, rating),
    review = COALESCE($2, review),
    rating_date = CURRENT_DATE
WHERE id = $3
RETURNING id, book_id, reader_id, rating, review, rating_date, created_at
`

type UpdateBookRatingParams struct {
	Rating   int       `json:"rating"`
	Review   *string   `json:"review"`
	RatingID uuid.UUID `json:"rating_id"`
}

func (q *Queries) UpdateBookRating(ctx context.Context, arg UpdateBookRatingParams) (*BookRating, error) {
	row := q.db.QueryRow(ctx, updateBookRating, arg.Rating, arg.Review, arg.RatingID)
	var i BookRating
	err := row.Scan(
		&i.ID,
		&i.BookID,
		&i.ReaderID,
		&i.Rating,
		&i.Review,
		&i.RatingDate,
		&i.CreatedAt,
	)
	return &i, err
}
