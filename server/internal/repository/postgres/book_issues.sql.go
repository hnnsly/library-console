// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: book_issues.sql

package postgres

import (
	"context"
	"time"

	"github.com/google/uuid"
)

const getBooksToReturn = `-- name: GetBooksToReturn :many
SELECT
    bi.id,
    r.ticket_number,
    r.full_name as reader_name,
    b.title,
    bc.copy_code,
    bi.issue_date,
    bi.due_date,
    CASE
        WHEN bi.due_date < CURRENT_DATE THEN (CURRENT_DATE - bi.due_date)
        ELSE 0
    END as days_overdue
FROM book_issues bi
JOIN readers r ON bi.reader_id = r.id
JOIN book_copies bc ON bi.book_copy_id = bc.id
JOIN books b ON bc.book_id = b.id
WHERE bi.return_date IS NULL
ORDER BY bi.due_date
`

type GetBooksToReturnRow struct {
	ID           uuid.UUID  `json:"id"`
	TicketNumber string     `json:"ticket_number"`
	ReaderName   string     `json:"reader_name"`
	Title        string     `json:"title"`
	CopyCode     string     `json:"copy_code"`
	IssueDate    *time.Time `json:"issue_date"`
	DueDate      time.Time  `json:"due_date"`
	DaysOverdue  int32      `json:"days_overdue"`
}

func (q *Queries) GetBooksToReturn(ctx context.Context) ([]*GetBooksToReturnRow, error) {
	rows, err := q.db.Query(ctx, getBooksToReturn)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetBooksToReturnRow{}
	for rows.Next() {
		var i GetBooksToReturnRow
		if err := rows.Scan(
			&i.ID,
			&i.TicketNumber,
			&i.ReaderName,
			&i.Title,
			&i.CopyCode,
			&i.IssueDate,
			&i.DueDate,
			&i.DaysOverdue,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOverdueBooks = `-- name: GetOverdueBooks :many
SELECT
    bi.id,
    r.ticket_number,
    r.full_name as reader_name,
    b.title,
    bc.copy_code,
    bi.issue_date,
    bi.due_date,
    (CURRENT_DATE - bi.due_date) as days_overdue
FROM book_issues bi
JOIN readers r ON bi.reader_id = r.id
JOIN book_copies bc ON bi.book_copy_id = bc.id
JOIN books b ON bc.book_id = b.id
WHERE bi.return_date IS NULL AND bi.due_date < CURRENT_DATE
ORDER BY bi.due_date
`

type GetOverdueBooksRow struct {
	ID           uuid.UUID  `json:"id"`
	TicketNumber string     `json:"ticket_number"`
	ReaderName   string     `json:"reader_name"`
	Title        string     `json:"title"`
	CopyCode     string     `json:"copy_code"`
	IssueDate    *time.Time `json:"issue_date"`
	DueDate      time.Time  `json:"due_date"`
	DaysOverdue  int32      `json:"days_overdue"`
}

func (q *Queries) GetOverdueBooks(ctx context.Context) ([]*GetOverdueBooksRow, error) {
	rows, err := q.db.Query(ctx, getOverdueBooks)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetOverdueBooksRow{}
	for rows.Next() {
		var i GetOverdueBooksRow
		if err := rows.Scan(
			&i.ID,
			&i.TicketNumber,
			&i.ReaderName,
			&i.Title,
			&i.CopyCode,
			&i.IssueDate,
			&i.DueDate,
			&i.DaysOverdue,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getReaderActiveBooks = `-- name: GetReaderActiveBooks :many
SELECT
    bi.id,
    b.title,
    bc.copy_code,
    bi.issue_date,
    bi.due_date
FROM book_issues bi
JOIN book_copies bc ON bi.book_copy_id = bc.id
JOIN books b ON bc.book_id = b.id
WHERE bi.reader_id = $1 AND bi.return_date IS NULL
ORDER BY bi.due_date
`

type GetReaderActiveBooksRow struct {
	ID        uuid.UUID  `json:"id"`
	Title     string     `json:"title"`
	CopyCode  string     `json:"copy_code"`
	IssueDate *time.Time `json:"issue_date"`
	DueDate   time.Time  `json:"due_date"`
}

func (q *Queries) GetReaderActiveBooks(ctx context.Context, readerID uuid.UUID) ([]*GetReaderActiveBooksRow, error) {
	rows, err := q.db.Query(ctx, getReaderActiveBooks, readerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetReaderActiveBooksRow{}
	for rows.Next() {
		var i GetReaderActiveBooksRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.CopyCode,
			&i.IssueDate,
			&i.DueDate,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRecentBookOperations = `-- name: GetRecentBookOperations :many
SELECT
    'issue' as operation_type,
    bi.created_at as operation_time,
    r.full_name as reader_name,
    r.ticket_number,
    b.title as book_title,
    bc.copy_code,
    u.username as librarian_name,
    bi.due_date::text as additional_info
FROM book_issues bi
JOIN readers r ON bi.reader_id = r.id
JOIN book_copies bc ON bi.book_copy_id = bc.id
JOIN books b ON bc.book_id = b.id
LEFT JOIN users u ON bi.librarian_id = u.id
WHERE bi.created_at >= $2

UNION ALL

SELECT
    'return' as operation_type,
    bi.updated_at as operation_time,
    r.full_name as reader_name,
    r.ticket_number,
    b.title as book_title,
    bc.copy_code,
    u.username as librarian_name,
    bi.return_date::text as additional_info
FROM book_issues bi
JOIN readers r ON bi.reader_id = r.id
JOIN book_copies bc ON bi.book_copy_id = bc.id
JOIN books b ON bc.book_id = b.id
LEFT JOIN users u ON bi.librarian_id = u.id
WHERE bi.return_date IS NOT NULL AND bi.updated_at >= $2

ORDER BY operation_time DESC
LIMIT $1
`

type GetRecentBookOperationsParams struct {
	LimitCount int32      `json:"limit_count"`
	SinceDate  *time.Time `json:"since_date"`
}

type GetRecentBookOperationsRow struct {
	OperationType  string     `json:"operation_type"`
	OperationTime  *time.Time `json:"operation_time"`
	ReaderName     string     `json:"reader_name"`
	TicketNumber   string     `json:"ticket_number"`
	BookTitle      string     `json:"book_title"`
	CopyCode       string     `json:"copy_code"`
	LibrarianName  *string    `json:"librarian_name"`
	AdditionalInfo string     `json:"additional_info"`
}

func (q *Queries) GetRecentBookOperations(ctx context.Context, arg GetRecentBookOperationsParams) ([]*GetRecentBookOperationsRow, error) {
	rows, err := q.db.Query(ctx, getRecentBookOperations, arg.LimitCount, arg.SinceDate)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetRecentBookOperationsRow{}
	for rows.Next() {
		var i GetRecentBookOperationsRow
		if err := rows.Scan(
			&i.OperationType,
			&i.OperationTime,
			&i.ReaderName,
			&i.TicketNumber,
			&i.BookTitle,
			&i.CopyCode,
			&i.LibrarianName,
			&i.AdditionalInfo,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const issueBook = `-- name: IssueBook :one
INSERT INTO book_issues (reader_id, book_copy_id, due_date, librarian_id)
VALUES ($1, $2, $3, $4)
RETURNING id, issue_date, due_date
`

type IssueBookParams struct {
	ReaderID    uuid.UUID  `json:"reader_id"`
	BookCopyID  uuid.UUID  `json:"book_copy_id"`
	DueDate     time.Time  `json:"due_date"`
	LibrarianID *uuid.UUID `json:"librarian_id"`
}

type IssueBookRow struct {
	ID        uuid.UUID  `json:"id"`
	IssueDate *time.Time `json:"issue_date"`
	DueDate   time.Time  `json:"due_date"`
}

func (q *Queries) IssueBook(ctx context.Context, arg IssueBookParams) (*IssueBookRow, error) {
	row := q.db.QueryRow(ctx, issueBook,
		arg.ReaderID,
		arg.BookCopyID,
		arg.DueDate,
		arg.LibrarianID,
	)
	var i IssueBookRow
	err := row.Scan(&i.ID, &i.IssueDate, &i.DueDate)
	return &i, err
}

const returnBook = `-- name: ReturnBook :one
UPDATE book_issues
SET return_date = CURRENT_DATE
WHERE book_copy_id = $1 AND return_date IS NULL
RETURNING id, reader_id, book_copy_id, issue_date, due_date, return_date
`

type ReturnBookRow struct {
	ID         uuid.UUID  `json:"id"`
	ReaderID   uuid.UUID  `json:"reader_id"`
	BookCopyID uuid.UUID  `json:"book_copy_id"`
	IssueDate  *time.Time `json:"issue_date"`
	DueDate    time.Time  `json:"due_date"`
	ReturnDate *time.Time `json:"return_date"`
}

func (q *Queries) ReturnBook(ctx context.Context, bookCopyID uuid.UUID) (*ReturnBookRow, error) {
	row := q.db.QueryRow(ctx, returnBook, bookCopyID)
	var i ReturnBookRow
	err := row.Scan(
		&i.ID,
		&i.ReaderID,
		&i.BookCopyID,
		&i.IssueDate,
		&i.DueDate,
		&i.ReturnDate,
	)
	return &i, err
}
