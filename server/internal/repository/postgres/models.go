// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0

package postgres

import (
	"database/sql/driver"
	"fmt"
	"net/netip"
	"time"

	"github.com/google/uuid"
	"github.com/govalues/decimal"
)

type ActionType string

const (
	ActionTypeLogin          ActionType = "login"
	ActionTypeLogout         ActionType = "logout"
	ActionTypeBookIssue      ActionType = "book_issue"
	ActionTypeBookReturn     ActionType = "book_return"
	ActionTypeBookExtend     ActionType = "book_extend"
	ActionTypeBookAdd        ActionType = "book_add"
	ActionTypeBookRemove     ActionType = "book_remove"
	ActionTypeReaderRegister ActionType = "reader_register"
	ActionTypeReaderUpdate   ActionType = "reader_update"
	ActionTypeFinePayment    ActionType = "fine_payment"
)

func (e *ActionType) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = ActionType(s)
	case string:
		*e = ActionType(s)
	default:
		return fmt.Errorf("unsupported scan type for ActionType: %T", src)
	}
	return nil
}

type NullActionType struct {
	ActionType ActionType `json:"action_type"`
	Valid      bool       `json:"valid"` // Valid is true if ActionType is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullActionType) Scan(value interface{}) error {
	if value == nil {
		ns.ActionType, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.ActionType.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullActionType) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.ActionType), nil
}

type BookStatus string

const (
	BookStatusAvailable BookStatus = "available"
	BookStatusIssued    BookStatus = "issued"
	BookStatusReserved  BookStatus = "reserved"
	BookStatusLost      BookStatus = "lost"
	BookStatusDamaged   BookStatus = "damaged"
)

func (e *BookStatus) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = BookStatus(s)
	case string:
		*e = BookStatus(s)
	default:
		return fmt.Errorf("unsupported scan type for BookStatus: %T", src)
	}
	return nil
}

type NullBookStatus struct {
	BookStatus BookStatus `json:"book_status"`
	Valid      bool       `json:"valid"` // Valid is true if BookStatus is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullBookStatus) Scan(value interface{}) error {
	if value == nil {
		ns.BookStatus, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.BookStatus.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullBookStatus) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.BookStatus), nil
}

type UserRole string

const (
	UserRoleAdministrator UserRole = "administrator"
	UserRoleLibrarian     UserRole = "librarian"
	UserRoleReader        UserRole = "reader"
)

func (e *UserRole) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = UserRole(s)
	case string:
		*e = UserRole(s)
	default:
		return fmt.Errorf("unsupported scan type for UserRole: %T", src)
	}
	return nil
}

type NullUserRole struct {
	UserRole UserRole `json:"user_role"`
	Valid    bool     `json:"valid"` // Valid is true if UserRole is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullUserRole) Scan(value interface{}) error {
	if value == nil {
		ns.UserRole, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.UserRole.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullUserRole) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.UserRole), nil
}

type Author struct {
	ID        uuid.UUID  `json:"id"`
	FullName  string     `json:"full_name"`
	BirthYear *int       `json:"birth_year"`
	DeathYear *int       `json:"death_year"`
	Biography *string    `json:"biography"`
	CreatedAt *time.Time `json:"created_at"`
}

type Book struct {
	ID              uuid.UUID  `json:"id"`
	Title           string     `json:"title"`
	Isbn            *string    `json:"isbn"`
	PublicationYear *int       `json:"publication_year"`
	Publisher       *string    `json:"publisher"`
	Pages           *int       `json:"pages"`
	Language        *string    `json:"language"`
	Description     *string    `json:"description"`
	TotalCopies     int        `json:"total_copies"`
	AvailableCopies int        `json:"available_copies"`
	CreatedAt       *time.Time `json:"created_at"`
	UpdatedAt       *time.Time `json:"updated_at"`
}

type BookAuthor struct {
	BookID   uuid.UUID `json:"book_id"`
	AuthorID uuid.UUID `json:"author_id"`
}

type BookCopy struct {
	ID             uuid.UUID      `json:"id"`
	BookID         uuid.UUID      `json:"book_id"`
	CopyCode       string         `json:"copy_code"`
	Status         NullBookStatus `json:"status"`
	ReadingHallID  *uuid.UUID     `json:"reading_hall_id"`
	ConditionNotes *string        `json:"condition_notes"`
	CreatedAt      *time.Time     `json:"created_at"`
	UpdatedAt      *time.Time     `json:"updated_at"`
}

type BookIssue struct {
	ID            uuid.UUID  `json:"id"`
	ReaderID      uuid.UUID  `json:"reader_id"`
	BookCopyID    uuid.UUID  `json:"book_copy_id"`
	IssueDate     *time.Time `json:"issue_date"`
	DueDate       time.Time  `json:"due_date"`
	ReturnDate    *time.Time `json:"return_date"`
	ExtendedCount *int       `json:"extended_count"`
	LibrarianID   *uuid.UUID `json:"librarian_id"`
	Notes         *string    `json:"notes"`
	CreatedAt     *time.Time `json:"created_at"`
	UpdatedAt     *time.Time `json:"updated_at"`
}

type BookRating struct {
	ID         uuid.UUID  `json:"id"`
	BookID     uuid.UUID  `json:"book_id"`
	ReaderID   uuid.UUID  `json:"reader_id"`
	Rating     int        `json:"rating"`
	Review     *string    `json:"review"`
	RatingDate *time.Time `json:"rating_date"`
	CreatedAt  *time.Time `json:"created_at"`
}

type Fine struct {
	ID          uuid.UUID       `json:"id"`
	ReaderID    uuid.UUID       `json:"reader_id"`
	BookIssueID *uuid.UUID      `json:"book_issue_id"`
	Amount      decimal.Decimal `json:"amount"`
	Reason      string          `json:"reason"`
	FineDate    *time.Time      `json:"fine_date"`
	PaidDate    *time.Time      `json:"paid_date"`
	PaidAmount  decimal.Decimal `json:"paid_amount"`
	IsPaid      *bool           `json:"is_paid"`
	LibrarianID *uuid.UUID      `json:"librarian_id"`
	CreatedAt   *time.Time      `json:"created_at"`
	UpdatedAt   *time.Time      `json:"updated_at"`
}

type Reader struct {
	ID               uuid.UUID  `json:"id"`
	UserID           *uuid.UUID `json:"user_id"`
	TicketNumber     string     `json:"ticket_number"`
	FullName         string     `json:"full_name"`
	BirthDate        time.Time  `json:"birth_date"`
	Phone            *string    `json:"phone"`
	Education        *string    `json:"education"`
	ReadingHallID    *uuid.UUID `json:"reading_hall_id"`
	RegistrationDate *time.Time `json:"registration_date"`
	IsActive         *bool      `json:"is_active"`
	CreatedAt        *time.Time `json:"created_at"`
	UpdatedAt        *time.Time `json:"updated_at"`
}

type ReadingHall struct {
	ID             uuid.UUID  `json:"id"`
	LibraryName    string     `json:"library_name"`
	HallName       string     `json:"hall_name"`
	Specialization *string    `json:"specialization"`
	TotalSeats     int        `json:"total_seats"`
	OccupiedSeats  *int       `json:"occupied_seats"`
	CreatedAt      *time.Time `json:"created_at"`
}

type SystemLog struct {
	ID              uuid.UUID   `json:"id"`
	UserID          *uuid.UUID  `json:"user_id"`
	ActionType      ActionType  `json:"action_type"`
	EntityType      *string     `json:"entity_type"`
	EntityID        *uuid.UUID  `json:"entity_id"`
	OldValues       []byte      `json:"old_values"`
	NewValues       []byte      `json:"new_values"`
	IpAddress       *netip.Addr `json:"ip_address"`
	UserAgent       *string     `json:"user_agent"`
	ActionTimestamp *time.Time  `json:"action_timestamp"`
	Details         *string     `json:"details"`
}

type User struct {
	ID           uuid.UUID  `json:"id"`
	Username     string     `json:"username"`
	Email        string     `json:"email"`
	PasswordHash string     `json:"password_hash"`
	Role         UserRole   `json:"role"`
	IsActive     *bool      `json:"is_active"`
	CreatedAt    *time.Time `json:"created_at"`
	UpdatedAt    *time.Time `json:"updated_at"`
}
