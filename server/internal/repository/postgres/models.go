// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0

package postgres

import (
	"database/sql/driver"
	"fmt"
	"time"

	"github.com/google/uuid"
	"github.com/govalues/decimal"
)

type BookStatus string

const (
	BookStatusAvailable BookStatus = "available"
	BookStatusIssued    BookStatus = "issued"
	BookStatusReserved  BookStatus = "reserved"
	BookStatusLost      BookStatus = "lost"
	BookStatusDamaged   BookStatus = "damaged"
)

func (e *BookStatus) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = BookStatus(s)
	case string:
		*e = BookStatus(s)
	default:
		return fmt.Errorf("unsupported scan type for BookStatus: %T", src)
	}
	return nil
}

type NullBookStatus struct {
	BookStatus BookStatus `json:"book_status"`
	Valid      bool       `json:"valid"` // Valid is true if BookStatus is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullBookStatus) Scan(value interface{}) error {
	if value == nil {
		ns.BookStatus, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.BookStatus.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullBookStatus) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.BookStatus), nil
}

type UserRole string

const (
	UserRoleAdministrator UserRole = "administrator"
	UserRoleLibrarian     UserRole = "librarian"
)

func (e *UserRole) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = UserRole(s)
	case string:
		*e = UserRole(s)
	default:
		return fmt.Errorf("unsupported scan type for UserRole: %T", src)
	}
	return nil
}

type NullUserRole struct {
	UserRole UserRole `json:"user_role"`
	Valid    bool     `json:"valid"` // Valid is true if UserRole is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullUserRole) Scan(value interface{}) error {
	if value == nil {
		ns.UserRole, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.UserRole.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullUserRole) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.UserRole), nil
}

type VisitType string

const (
	VisitTypeEntry VisitType = "entry"
	VisitTypeExit  VisitType = "exit"
)

func (e *VisitType) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = VisitType(s)
	case string:
		*e = VisitType(s)
	default:
		return fmt.Errorf("unsupported scan type for VisitType: %T", src)
	}
	return nil
}

type NullVisitType struct {
	VisitType VisitType `json:"visit_type"`
	Valid     bool      `json:"valid"` // Valid is true if VisitType is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullVisitType) Scan(value interface{}) error {
	if value == nil {
		ns.VisitType, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.VisitType.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullVisitType) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.VisitType), nil
}

type Author struct {
	ID        uuid.UUID  `json:"id"`
	FullName  string     `json:"full_name"`
	CreatedAt *time.Time `json:"created_at"`
}

type Book struct {
	ID              uuid.UUID  `json:"id"`
	Title           string     `json:"title"`
	Isbn            *string    `json:"isbn"`
	PublicationYear *int       `json:"publication_year"`
	Publisher       *string    `json:"publisher"`
	TotalCopies     int        `json:"total_copies"`
	AvailableCopies int        `json:"available_copies"`
	CreatedAt       *time.Time `json:"created_at"`
}

type BookAuthor struct {
	BookID   uuid.UUID `json:"book_id"`
	AuthorID uuid.UUID `json:"author_id"`
}

type BookCopy struct {
	ID           uuid.UUID      `json:"id"`
	BookID       uuid.UUID      `json:"book_id"`
	CopyCode     string         `json:"copy_code"`
	Status       NullBookStatus `json:"status"`
	HallID       *uuid.UUID     `json:"hall_id"`
	LocationInfo *string        `json:"location_info"`
	CreatedAt    *time.Time     `json:"created_at"`
}

type BookIssue struct {
	ID          uuid.UUID  `json:"id"`
	ReaderID    uuid.UUID  `json:"reader_id"`
	BookCopyID  uuid.UUID  `json:"book_copy_id"`
	IssueDate   *time.Time `json:"issue_date"`
	DueDate     time.Time  `json:"due_date"`
	ReturnDate  *time.Time `json:"return_date"`
	LibrarianID *uuid.UUID `json:"librarian_id"`
	CreatedAt   *time.Time `json:"created_at"`
}

type Fine struct {
	ID          uuid.UUID       `json:"id"`
	ReaderID    uuid.UUID       `json:"reader_id"`
	BookIssueID *uuid.UUID      `json:"book_issue_id"`
	Amount      decimal.Decimal `json:"amount"`
	Reason      string          `json:"reason"`
	FineDate    *time.Time      `json:"fine_date"`
	PaidDate    *time.Time      `json:"paid_date"`
	IsPaid      *bool           `json:"is_paid"`
	CreatedAt   *time.Time      `json:"created_at"`
}

type HallVisit struct {
	ID          uuid.UUID  `json:"id"`
	ReaderID    uuid.UUID  `json:"reader_id"`
	HallID      uuid.UUID  `json:"hall_id"`
	VisitType   VisitType  `json:"visit_type"`
	VisitTime   *time.Time `json:"visit_time"`
	LibrarianID *uuid.UUID `json:"librarian_id"`
}

type Reader struct {
	ID               uuid.UUID  `json:"id"`
	TicketNumber     string     `json:"ticket_number"`
	FullName         string     `json:"full_name"`
	Email            *string    `json:"email"`
	Phone            *string    `json:"phone"`
	RegistrationDate *time.Time `json:"registration_date"`
	IsActive         *bool      `json:"is_active"`
	CreatedAt        *time.Time `json:"created_at"`
}

type ReadingHall struct {
	ID              uuid.UUID  `json:"id"`
	HallName        string     `json:"hall_name"`
	Specialization  *string    `json:"specialization"`
	TotalSeats      int        `json:"total_seats"`
	CurrentVisitors *int       `json:"current_visitors"`
	CreatedAt       *time.Time `json:"created_at"`
}

type User struct {
	ID           uuid.UUID  `json:"id"`
	Username     string     `json:"username"`
	Email        string     `json:"email"`
	PasswordHash string     `json:"password_hash"`
	Role         UserRole   `json:"role"`
	IsActive     *bool      `json:"is_active"`
	CreatedAt    *time.Time `json:"created_at"`
}
