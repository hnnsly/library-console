// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: operations.sql

package postgres

import (
	"context"
	"time"
)

const createOperationLog = `-- name: CreateOperationLog :exec
INSERT INTO operation_logs (
    operation_type, entity_type, entity_id, librarian_id, details, description
) VALUES (
    $1, $2, $3, $4, $5, $6
)
`

type CreateOperationLogParams struct {
	OperationType string  `json:"operation_type"`
	EntityType    string  `json:"entity_type"`
	EntityID      int     `json:"entity_id"`
	LibrarianID   *int    `json:"librarian_id"`
	Details       []byte  `json:"details"`
	Description   *string `json:"description"`
}

func (q *Queries) CreateOperationLog(ctx context.Context, arg CreateOperationLogParams) error {
	_, err := q.db.Exec(ctx, createOperationLog,
		arg.OperationType,
		arg.EntityType,
		arg.EntityID,
		arg.LibrarianID,
		arg.Details,
		arg.Description,
	)
	return err
}

const getOperationLogs = `-- name: GetOperationLogs :many
SELECT ol.id, ol.operation_type, ol.entity_type, ol.entity_id, ol.librarian_id, ol.operation_date, ol.details, ol.description, l.full_name as librarian_name
FROM operation_logs ol
LEFT JOIN librarians l ON ol.librarian_id = l.id
WHERE ($1::text IS NULL OR ol.entity_type = $1)
  AND ($2::int IS NULL OR ol.entity_id = $2)
  AND ol.operation_date >= CURRENT_DATE - INTERVAL '@days_back days'
ORDER BY ol.operation_date DESC
LIMIT $4 OFFSET $3
`

type GetOperationLogsParams struct {
	EntityType string `json:"entity_type"`
	EntityID   int    `json:"entity_id"`
	PageOffset int32  `json:"page_offset"`
	PageLimit  int32  `json:"page_limit"`
}

type GetOperationLogsRow struct {
	ID            int64     `json:"id"`
	OperationType string    `json:"operation_type"`
	EntityType    string    `json:"entity_type"`
	EntityID      int       `json:"entity_id"`
	LibrarianID   *int      `json:"librarian_id"`
	OperationDate time.Time `json:"operation_date"`
	Details       []byte    `json:"details"`
	Description   *string   `json:"description"`
	LibrarianName *string   `json:"librarian_name"`
}

func (q *Queries) GetOperationLogs(ctx context.Context, arg GetOperationLogsParams) ([]*GetOperationLogsRow, error) {
	rows, err := q.db.Query(ctx, getOperationLogs,
		arg.EntityType,
		arg.EntityID,
		arg.PageOffset,
		arg.PageLimit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetOperationLogsRow{}
	for rows.Next() {
		var i GetOperationLogsRow
		if err := rows.Scan(
			&i.ID,
			&i.OperationType,
			&i.EntityType,
			&i.EntityID,
			&i.LibrarianID,
			&i.OperationDate,
			&i.Details,
			&i.Description,
			&i.LibrarianName,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRecentOperations = `-- name: GetRecentOperations :many
SELECT ol.id, ol.operation_type, ol.entity_type, ol.entity_id, ol.librarian_id, ol.operation_date, ol.details, ol.description, l.full_name as librarian_name
FROM operation_logs ol
LEFT JOIN librarians l ON ol.librarian_id = l.id
ORDER BY ol.operation_date DESC
LIMIT $1
`

type GetRecentOperationsRow struct {
	ID            int64     `json:"id"`
	OperationType string    `json:"operation_type"`
	EntityType    string    `json:"entity_type"`
	EntityID      int       `json:"entity_id"`
	LibrarianID   *int      `json:"librarian_id"`
	OperationDate time.Time `json:"operation_date"`
	Details       []byte    `json:"details"`
	Description   *string   `json:"description"`
	LibrarianName *string   `json:"librarian_name"`
}

func (q *Queries) GetRecentOperations(ctx context.Context, resultLimit int32) ([]*GetRecentOperationsRow, error) {
	rows, err := q.db.Query(ctx, getRecentOperations, resultLimit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetRecentOperationsRow{}
	for rows.Next() {
		var i GetRecentOperationsRow
		if err := rows.Scan(
			&i.ID,
			&i.OperationType,
			&i.EntityType,
			&i.EntityID,
			&i.LibrarianID,
			&i.OperationDate,
			&i.Details,
			&i.Description,
			&i.LibrarianName,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
